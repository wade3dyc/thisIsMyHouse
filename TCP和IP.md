# TCP保证数据可靠性

1）**应用数据被分割成TCP认为最合适发送的数据块**，当建立一个连接时，每一方都有用于通告它期望接收的MSS（最大报文段长度），MSS选项只能出现在SYN报文段中。如果一方不接收来自另一方的MSS值，则MSS就默认为536字节+20字节IP首部和TCP首部。

2）**当TCP发出一个报文段后，它启动一个定时器**，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段。 第一次发送后所设置的超时时间实际上为1.5秒，此后该时间在每次重传时增加一倍，一直到64秒，采用的是指数退避算法。一共重传**12**次，大约9分钟才放弃重传 。（拔掉服务器以太网电缆，上面为客户端的操作）

3）**当TCP收到来自TCP连接另外一段的数据，它将发送一个确认**。通常TCP在接收到数据时并不立即发送ACK，相反，TCP将以最大200ms的时延等待是否有数据一起发送。

4）**TCP有16位的检验和**，如果校验和有差错，TCP将丢弃这个报文段，并希望发送端超时并发送。

5）**TCP报文段的到达可能会失序**。如果必要的话，TCP将对收到的数据进行重新排序，将收到的数据以正确的顺序交给应用层。

6）TCP的接收端必须**丢弃重复的数据**。

7）TCP能提供**流量控制**，TCP双方都有固定的缓冲空间，TCP的接收端允许另一端发生接收端缓冲区所能接纳的数据。这将防止较快主机致较慢主机的缓冲区溢出。

# TCP的首部

TCP首部一般是**20字节**，最大到**60字节**。TCP首部一般是**20字节**。

<img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/55dc4e84-573d-4c13-a765-52ed1dd251f9.png" width="700"/> 

**TCP将用户数据打包构成报文段；它发送数据后启动一个定时器；另一端对收到的数据进行确认，对失序的数据重新排序，丢弃重复数据； TCP提供端到端的流量控制，并计算和验证一个强制性的端到端检验和。**

1）每个TCP段都包含**源端和目的端的端口号**，用于寻找发端和收端**应用进程**。这两个值加上IP首部中的源端IP地址和目的端IP地址唯一确定一个TCP连接。一个IP地址和一个端口号也称为一个socket。

2）**序号**用来标识从TCP发端向TCP收端发送的数据字节流，它表示在这个报文段中的第一个数据字节。TCP用序号对每个字节进行计数。序号是32 bit的无符号数，序号到达最大值后又从0开始。

3）当建立一个新的连接时，**SYN标志**变1。序号字段包含由这个主机选择的该连接的初始序号ISN。该主机要发送数据的第一个字节序号为这个ISN加1，因为**SYN标志消耗了一个序号，FIN标志也要占用一个序号**。（为什么不是从0开始，1. 预防TCP序列预测攻击.2. 目的在于防止在网络中被延迟的分组在以后又被传送，而导致某个连接的一方对它作错误的解释 ）

4）**确认序号**包含发送确认的一端所期望收到的下一个序号。因此，确认序号应当是上次已成功收到数据字节序号加 1。只有ACK标志为1时确认序号字段才有效。

5）TCP的流量控制由连接的每一端通过声明的窗口大小来提供。**窗口**大小为字节数，起始于确认序号字段指明的值，这个值是接收端正期望接收的字节。

6）**检验和**覆盖了整个的TCP报文段：TCP首部和TCP数据。

7）最常见的**可选字段**是**最长报文大小**，又称为 MSS 。每个连接方通常都在通信的第一个报文段（为建立连接而设置 SYN标志的那个段）中指明这个选项。它指明本端所能接收的最大长度的报文段。最长报文段是不包含头部的。

8）TCP报文段中的**数据部分**是可选的。一个连接建立和一个连接终止时，双方交换的报文段仅有TCP首部。

# 三次握手

1) 请求端（通常称为客户）发送一个 SYN段指明客户打算连接的服务器的端口，以及初始序号。这个SYN段为报文段1。同时它指明本端所能接收的最大长度的报文段。
2) 服务器发回包含服务器的初始序号的 SYN报文段（报文段2）作为应答。同时，将确认序号设置为客户的ISN加1以对客户的SYN报文段进行确认。一个SYN将占用一个序号。同时它指明本端所能接收的最大长度的报文段。
3) 客户必须将确认序号设置为服务器的 ISN加1以对服务器的SYN报文段进行确认（报文段3）。
这三个报文段完成连接的建立。这个过程也称为三次握手。

## 为什么客户端还要发送一次确认呢

主要防止已经A失效的连接请求报文段突然又传送到了B。B却以为新连接已建立，浪费了大量资源。

## 连接建立超时

一般超时会再发送2次SYN,第2个SYN与第1个的间隔是5.5~6秒，而第3个与第2个的间隔是24秒。

# 四次握手

既然一个TCP连接是全双工（即数据在两个方向上能同时传递），因此每个方向必须单独地进行关闭。这原则就是当**任一方**完成它的数据发送任务后就能发送一个 FIN来终止这个方向连接。

1) 当客户端发送一个FIN（报文段4），停止发送数据，主动关闭TCP连接。

2) 当服务器收到这个FIN，它发回一个ACK，确认序号为收到的序号加 1（报文段5）。

3) 服务器发送完数据后，发送一个FIN（报文段6）。

4)  客户必须发回一个确认，并将确认序号设置为收到序号加1（报文段7）。再等2MSL(最长报文段寿命)后，彻底关闭。

## TIME_WAIT(2MSL)的意义

1) 让TCP再次发送最后的ACK以防这个ACK丢失（另一端超时并重发最后的FIN）。

2) 此次连接的所有报文都会消失，不会影响下次连接。 

## 为什么一般都是客户端先发送FIN

1) 一般由客户端决定何时终止连接，因为客户进程通常由用户交互控制，用户会键入诸如“ quit”一样的命令来终止进程。

 2) TCP连接在2MSL等待期间，定义这个连接的插口(客户的IP地址和端口号，服务器的IP地址和端口号)不能再被使用。这个连接只能在2MSL结束后才能再被使用。

## FIN_WAIT_2 状态

在FIN_WAIT_2状态我们已经发出了FIN，并且另一端也已对它进行确认。只有当另一端的进程完成这个关闭，我们这端才会从FIN_WAIT_2状态进入TIME_WAIT状态。这意味着我们这端可能永远保持这个状态。

防止这种在FIN_WAIT_2状态的无限等待。如果执行主动关闭的应用层将进行全关闭，而不是半关闭来说明它还想接收数据，就设置一个定时器。如果这个连接空闲10分钟75秒，TCP将进入CLOSED状态。

# 流量控制（滑动窗口）

该协议允许发送方在停止并等待确认前可以连续发送多个分组。由于发送方不必每发一个分组就停下来等待确认，因此该协议可以加速数据的传输。   

使用TCP的滑动窗口协议时，接收方不必确认每一个收到的分组。在TCP中，ACK是累积的—它们表示接收方已经正确收到了一直到确认序号减 1的所有字节。

1) 称窗口左边沿向右边沿靠近为窗口合拢。这种现象发生在数据被发送和确认时。

2) 当窗口右边沿向右移动时将允许发送更多的数据，我们称之为窗口张开。这种现象发生在另一端的接收进程读取已经确认的数据并释放了 TCP的接收缓存时。

3) 当右边沿向左移动时，我们称之为窗口收缩。

4)如果左边沿到达右边沿，则称其为一个零窗口，此时发送方不能够发送任何数据。

# 拥塞控制

**拥塞窗口**是发送方使用的流量控制，而**通告窗口**则是接收方使用的流量控制。TCP输出例程的输出不能超过cwnd和接收方通告窗口的大小。**前者是发送方感受到的网络拥塞的估计，而后者则与接收方在该连接上的可用缓存大小有关。**使用慢启动算法，通过观察到新分组进入网络的速率应该与另一端返回确认的速率相同而进行工作。

**慢启动：**该算法通过观察到新分组进入网络的速率应该与另一端返回确认的速率相同而进行工作。当拥塞发生时，我们希望降低分组进入网络的传输速率，于是可以调用慢启动来作到这一点。

拥塞窗口被初始化为 1个报文段（即另一端通告的报文段大小）。每收到一个ACK，拥塞窗口就增加一个报文段（ cwnd以字节为单位，但是慢启动以报文段大小为单位进行增加）。发送方取拥塞窗口与通告窗口中的最小值作为发送上限。

发送方开始时发送一个报文段，然后等待 ACK。当收到该ACK时，拥塞窗口从1增加为2，即可以发送两个报文段。当收到这两个报文段的 ACK时，拥塞窗口就增加为4。这是一种指数增加的关系。

**拥塞避免：**

1) 对一个给定的连接，初始化cwnd为1个报文段，ssthresh为65535个字节。
2) 当拥塞发生时（超时或收到重复确认），ssthresh被设置为当前窗口大小的一半（cwnd和接收方通告窗口大小的最小值，但最少为 2个报文段）。此外，如果是**超时引起了拥塞**，则cwnd被设置为1个报文段（这就是慢启动），如果是**重复确认引起了拥塞**，则cwnd被设置为ssthresh（这就是快恢复）。
3) 当新的数据被对方确认时，就增加 cwnd，但增加的方法依赖于我们是否正在进行慢启动或拥塞避免。如果cwnd小于或等于ssthresh，则正在进行慢启动，否则正在进行拥塞避免。

​		**慢启动算法**初始设置 cwnd为1个报文段，此后每收到一个确认就加 1。这会使窗口按指数方式增长：发送 1个报文段，然后是2个，接着是4个⋯⋯。
​		**拥塞避免算法**要求每次收到一个确认时将 cwnd增加1 /cwnd。与慢启动的指数增加比起来，这是一种加性增长(additive increase)。我们希望在一个往返时间内最多为cwnd增加1个报文段（不管在这个RTT中收到了多少个ACK），然而慢启动将根据这个往返时间中所收到的确认的个数增加cwnd。

**快重传和快恢复：**

**快速重传算法：**假如这只是一些报文段的重新排序，则在重新排序的报文段被处理并产生一个新的ACK之前，只可能产生1 ~ 2个重复的ACK。如果一连串收到 3个或3个以上的重复ACK，就非常可能是一个报文段丢失了。于是我们就重传丢失的数据报文段，而无需等待超时定时器溢出。 

**快速恢复算法**：ssthresh立即设置为当重传发生时正在起作用的窗口大小的一半，但是在接收到重复 ACK的过程中cwnd允许保持增加，这是因为每个重复的ACK表示1个报文段已离开了网络（接收 T C P已缓存了这个报文段，等待所缺数据的到达）。

**没有执行慢启动的原因：**

收到重复的ACK不仅仅告诉我们一个分组丢失了。由于接收方只有在收到另一个报文段时才会产生重复的ACK，而该报文段已经离开了网络并进入了接收方的缓存。也就是说，在收发两端之间仍然有流动的数据，而我们不想执行慢启动来突然减少数据流。































  