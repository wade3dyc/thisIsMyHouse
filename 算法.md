# 面试高频题

## 面试题 17.14（最小K个数)

```c++
设计一个算法，找出数组中最小的k个数。以任意顺序返回这k个数均可。
示例：

输入： arr = [1,3,5,7,2,4,6,8], k = 4
输出： [1,2,3,4]
```

```c++
//思路一：堆排

class Solution {
public:
    vector<int> smallestK(vector<int>& arr, int k)
    {
        vector<int> res;
        if (arr.size() <= k) return arr;
        priority_queue<int, vector<int>, less<int> > pq;
        for (int& num : arr) {
            pq.push(num);
            if (pq.size() > k) {
                pq.pop();
            }
        }
        while (!pq.empty()) {
            res.push_back(pq.top());
            pq.pop();
        }
        return res;
    }
};

//思路二：快排
class Solution {
public:
    int patition(vector<int>& arr, int left, int right) {
        if (left >= right) return left;
        int i = left;
        int j = right + 1;
        int num = arr[left];
        while (true) {
            while (arr[++i] < num) {
                if (i == right) break;
            }
            while (arr[--j] > num) {
                if (j == left) break;
            }
            if (i >= j) break;
            swap(arr[i], arr[j]);
        }
        swap(arr[left], arr[j]);
        return j;
    }
    vector<int> smallestK(vector<int>& arr, int k)
    {
        vector<int> res;
        if (arr.size() <= k) return arr;
        int right = arr.size() - 1;
        int left = 0;
        while (left <= right) {
            int j = patition(arr, left, right);
            if (j == k - 1) {
                return vector<int>(arr.begin(), arr.begin() + k);
            }
            else if (j < k - 1) left = j + 1;
            else right = j - 1;
        }
        return res;
    }
};
```

## 前 K 个高频元素(leetcode347)

```c++
输入 : nums = [1, 1, 1, 2, 2, 3], k = 2
输出 : [1, 2]
```

```c++
//less默认最大堆，而greater是最小堆。
//less表示按照递减(从大到小)的顺序插入元素
//greater表示按照递增（从小到大）的顺序插入元素
class Solution {
public:
    vector<int> topKFrequent(vector<int>& nums, int k)
    {
        vector<int> res;
        unordered_map<int, int> m1;
        for (int num : nums)
        {
            ++m1[num];
        }
        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> q;
        for (auto& x : m1)
        {
            q.emplace(x.second, x.first);// pair比较的是第一个值，而我们需要比较的是第二个值。
            if (q.size() > k) {
                q.pop();
            }
        }
        while (!q.empty())
        {
            res.push_back(q.top().second);
            q.pop();
        }
        return res;
    }
};

//自定义cmp
class Solution {
public:
    struct cmp {
        bool operator()(pair<int, int>& m, pair<int, int>& n) {
            return m.second > n.second;
        }
    };
    vector<int> topKFrequent(vector<int>& nums, int k)
    {
        vector<int> res;
        unordered_map<int, int> m1;
        for (int num : nums)
        {
            ++m1[num];
        }
        priority_queue<pair<int, int>, vector<pair<int, int>>, cmp> q;
        for (auto& x : m1)
        {
            q.push(x);
            if (q.size() > k) {
                q.pop();
            }
        }
        while (!q.empty())
        {
            res.push_back(q.top().first);
            q.pop();
        }
        return res;
    }
};
```

## 二叉树的前序遍历（leetcode144)

```c++
vector<int> preorderTraversal(TreeNode* root) 
{
    vector<int> res;
    if(root==nullptr) return res;
    stack<TreeNode*> s1;
    while(root||!s1.empty()){
        if(root){
            s1.push(root);
            res.push_back(root->val);
            root=root->left;
        }
        else {
            root=s1.top();
            s1.pop();
            root=root->right;
        }
    }
    return res;
}
```

## 二叉树的中序遍历（leetcode94）

```c++
vector<int> inorderTraversal(TreeNode* root) 
{
    vector<int> res;
    if(root==nullptr) return res;
    stack<TreeNode*> s1;
    while(root||!s1.empty()){
        if(root){
            s1.push(root);
            root=root->left;
        }
        else {
            root=s1.top();
            s1.pop();
            res.push_back(root->val);
            root=root->right;
        }
    }
    return res;
}
```

## 二叉树的后序遍历（leetcode145）

```c++
class Solution {
public:
    vector<int> ans;
    vector<int> postorderTraversal(TreeNode* root) 
    {
        if(root==nullptr) return ans;
        bfs(root);
        return ans;
    }
    void bfs(TreeNode* root)
    {
        stack<TreeNode*> sta1;
        stack<int> res;
        sta1.push(root);
        while(!sta1.empty()){
            TreeNode* node=sta1.top();
            res.push(node->val);
            sta1.pop();
            if(node->left) sta1.push(node->left);
            if(node->right) sta1.push(node->right);
        }
        while(!res.empty()){
            ans.push_back(res.top());
            res.pop();
        }
    }
};
```

## LRU缓存（leetcode146)

```c++
class LRUCache {
public: 
    unordered_map<int,list<pair<int,int>>::iterator> m1;
    list<pair<int,int>> l1;//双向链表（可以从中间去掉节点，可直接找到最后一个节点去除掉）
    int cap;
    LRUCache(int capacity) 
    {
        this->cap=capacity;
    }
    
    int get(int key) 
    {
        if(m1.count(key)){
            auto node=*m1[key];//不要去取迭代器的值出来
            l1.erase(m1[key]);
            l1.push_front(node);
            m1[key]=l1.begin();
            return node.second;
        }
        return -1;
    }
    
    void put(int key, int value) 
    {
        if(m1.count(key)){
            l1.erase(m1[key]);
        }
        else if(cap==0){
            m1.erase(l1.back().first);
            l1.pop_back();
        }
        else{
            --cap;
        }
        pair<int,int> node=make_pair(key,value);
        l1.push_front(node);
        m1[key]=l1.begin();
        return ;
    }
};
```

## 排序数组（leetcode912）

```c++
输入：nums = [5,2,3,1]
输出：[1,2,3,5]
```

```c++
//快速排序
class Solution {
public:
    int partition(vector<int>& nums,int low,int high){
        if(low>=high) return low;
        int p=nums[low];
        int i=low;
        int j=high+1;
        while(true){
            while(nums[++i]<p){
                if(i==high) break;
            }
            while(nums[--j]>p){
                if(j==low) break;
            }
            if(i>=j) break;
            swap(nums[i],nums[j]);
        }
        swap(nums[low],nums[j]);
        return j;
    }
    vector<int> sortArray(vector<int>& nums) 
    {
        if(nums.size()==1) return nums;
        quickSort(nums,0,nums.size()-1);
        return nums;
    }
    void quickSort(vector<int>& nums,int left,int right)
    {
        if(left>=right) return;
        int mid=partition(nums,left,right);
        quickSort(nums,left,mid-1);
        quickSort(nums,mid+1,right);
        return ;
    }
};
```

```c++
//归并算法
class Solution {
    vector<int> tmp;
    void mergeSort(vector<int>& nums, int l, int r) {
        if (l >= r) return;
        int mid = (l + r) >> 1;
        mergeSort(nums, l, mid);
        mergeSort(nums, mid + 1, r);
        int i = l, j = mid + 1;
        int cnt = 0;
        while (i <= mid && j <= r) {
            if (nums[i] <= nums[j]) {
                tmp[cnt++] = nums[i++];
            }
            else {
                tmp[cnt++] = nums[j++];
            }
        }
        while (i <= mid) {
            tmp[cnt++] = nums[i++];
        }
        while (j <= r) {
            tmp[cnt++] = nums[j++];
        }
        for (int i = 0; i < r - l + 1; ++i) {
            nums[i + l] = tmp[i];
        }
    }
public:
    vector<int> sortArray(vector<int>& nums) {
        tmp.resize((int)nums.size(), 0);
        mergeSort(nums, 0, (int)nums.size() - 1);
        return nums;
    }
};
```



## 回文链表

```c++
请判断一个链表是否为回文链表。

示例 1:
输入: 1->2
输出: false

示例 2:
输入: 1->2->2->1
输出: true
```

```c++
class Solution {
public:
    bool isPalindrome(ListNode* head) 
    {
        if(head==nullptr) return false;
        ListNode* slow=head;
        ListNode* fast=head;
        ListNode* temp;
        ListNode* pre=nullptr;
        while(fast&&fast->next){
            fast=fast->next->next;
            temp=slow;
            slow=slow->next;
            temp->next=pre;
            pre=temp;            
        }
        if(fast!=nullptr) slow=slow->next;
        while(slow){
            if(slow->val!=temp->val) return false;
            slow=slow->next;
            temp=temp->next;
        }
        return true;
    }
};
```

## 最长公共子序列（leetcode1143）

```c++
输入：text1 = "abcde", text2 = "ace" 
输出：3  
解释：最长公共子序列是 "ace" ，它的长度为 3 。
```

```c++
class Solution {
public:
    int longestCommonSubsequence(string text1, string text2) 
    {
        int size1=text1.size();
        int size2=text2.size();
        vector<vector<int>> vec(size1+1,vector<int>(size2+1,0));
        for(int i=1;i<=size1;++i){
            for(int j=1;j<=size2;++j){
                if(text1[i-1]==text2[j-1]){
                    vec[i][j]=vec[i-1][j-1]+1;
                }else{
                    vec[i][j]=max(vec[i-1][j],vec[i][j-1]);
                }
            }
        }
        return vec[size1][size2];
    }
};
```

## 合并有序链表（leetcode21）

```c++
class Solution {
public:
    ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) 
    {
        if(l1==nullptr) return l2;
        if(l2==nullptr) return l1;
        if(l1->val<l2->val){
            l1->next=mergeTwoLists(l1->next,l2);
            return l1;
        }
        l2->next=mergeTwoLists(l1,l2->next);
        return l2;
    }
};
```

```c++
class Solution {
public:
    ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) 
    {
        ListNode* head=new ListNode();
        ListNode* pre=head;
        while(l1||l2){
            if(l1==nullptr){
                pre->next=l2;
                break;
            }else if(l2==nullptr){
                pre->next=l1;
                break;
            }else{
                if(l1->val<l2->val){
                    pre->next=l1;
                    pre=pre->next;
                    l1=l1->next;               
                }else{
                    pre->next=l2;
                    pre=pre->next;
                    l2=l2->next; 
                }
            }
        }
        return head->next;
    }
};
```

## 正则表达式（leetcode10）

```c++
给你一个字符串 s 和一个字符规律 p，请你来实现一个支持 '.' 和 '*' 的正则表达式匹配。

    '.' 匹配任意单个字符
    '*' 匹配零个或多个前面的那一个元素

所谓匹配，是要涵盖 整个 字符串 s的，而不是部分字符串。
 

示例 1：

输入：s = "aa" p = "a"
输出：false
解释："a" 无法匹配 "aa" 整个字符串。
```

```c++
class Solution {
public:
    bool isMatch(string s, string p) 
    {
        vector<vector<bool>> vec(s.size()+1,vector<bool>(p.size()+1,false));
        vec[0][0]=true;
        for(int i=0;i<=s.size();++i){
            for(int j=1;j<=p.size();++j){
                if(p[j-1]!='*'){
                    if(i>=1&&(p[j-1]==s[i-1]||p[j-1]=='.')){
                        vec[i][j]=vec[i-1][j-1];
                    }
                }else{
                    if(j>=2){
                        vec[i][j]=vec[i][j]||vec[i][j-2];
                    }  
                    if(i>=1&&j>=2&&(p[j-2]==s[i-1]||p[j-2]=='.')){
                        vec[i][j]=vec[i][j]||vec[i-1][j];
                    }                 
                }
            }
        }
        return vec[s.size(][p.size()];
    }
};
```

## 字节跳动

### 有序链表转换二叉搜索树（leetcode109）

```c++
给定一个单链表，其中的元素按升序排序，将其转换为高度平衡的二叉搜索树。
本题中，一个高度平衡二叉树是指一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1。
示例:
给定的有序链表： [-10, -3, 0, 5, 9],
一个可能的答案是：[0, -3, 9, -10, null, 5], 它可以表示下面这个高度平衡二叉搜索树：
      0
     / \
   -3   9
   /   /
 -10  5
```

```c++
class Solution {
public:

    TreeNode* sortedListToBST(ListNode* head) 
    {
        if(head==nullptr) return nullptr;
        if(head->next==nullptr) return new TreeNode(head->val);
        ListNode* fast=head;
        ListNode* slow=head;
        ListNode* pre;
        while(fast&&fast->next){
            fast=fast->next->next;
            pre=slow;
            slow=slow->next;
        }
        pre->next=nullptr;
        ListNode* temp=slow->next;
        TreeNode* newNode=new TreeNode(slow->val);
        newNode->left = sortedListToBST(head);
        newNode->right = sortedListToBST(temp);
        return newNode;
    }
};
```

### 长度最小的子数组（leetcode209）

```c++
给定一个含有 n 个正整数的数组和一个正整数 target 。

找出该数组中满足其和 ≥ target 的长度最小的 连续子数组 [numsl, numsl+1, ..., numsr-1, numsr] ，并返回其长度。如果不存在符合条件的子数组，返回 0 。
示例 1：

输入：target = 7, nums = [2,3,1,2,4,3]
输出：2
解释：子数组 [4,3] 是该条件下的长度最小的子数组。
```

```c++
class Solution {
public:
    int minSubArrayLen(int target, vector<int>& nums) 
    {
        int i=0;
        int sum=0;
        int len=INT_MAX;
        for(int j=0;j<nums.size();++j){
            sum+=nums[j];
            while(sum>=target){
                len=min(len,j-i+1);
                sum-=nums[i++];
            }
        }
        return len==INT_MAX?0:len;
    }
};
```

### K 个一组翻转链表（leetcode25）

```c++
输入：head = [1,2,3,4,5], k = 3
输出：[3,2,1,4,5]
```

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* reverseKGroup(ListNode* head, int k) 
    {
        ListNode* temp=head;
        int length=0;
        while(temp){
            ++length;
            temp=temp->next;
        }
        ListNode* res=new ListNode();
        res->next=head;
        ListNode* pre=res;
        temp=head;
        ListNode* next;
        for(int i=0;i<length/k;++i)
        {
            for(int j=0;j<k-1;++j)
            {
                next=temp->next;
                temp->next=next->next;
                next->next=pre->next;
                pre->next=next;             
            }
            pre=temp;
            temp=temp->next;
        }
        return res->next;
    }
};
```

### 无重复字符的最长子串（leetcode3）

```c++
输入: s = "abcabcbb"
输出: 3 
解释: 因为无重复字符的最长子串是 "abc"，所以其长度为 3。
```

```c++
class Solution {
public:
    int lengthOfLongestSubstring(string s) 
    {
        if(s.size()==0) return 0;
        unordered_map<char,int> window;
        int left=0;
        int right=0;
        int len=0;
        while(right<s.size())
        {
            char c=s[right];
            ++right;
            ++window[c];
            while(window[c]>1){
                char d=s[left++];
                --window[d];
            }
            len=max(len,right-left);
        }
        return len;
    }
};
```

### 反转链表（leetcode206）

```c++
输入：head = [1,2,3,4,5]
输出：[5,4,3,2,1]
```

```c++
//两个节点交换
class Solution {
public:
    ListNode* reverseList(ListNode* head) 
    {
        if(head==nullptr) return nullptr;
        ListNode* pre=new ListNode();
        pre->next=head;
        ListNode* temp=head;
        ListNode* next;
        while(temp->next){
            next=temp->next;
            temp->next=next->next;
            next->next=pre->next;
            pre->next=next;
        }
        return pre->next;
    }
};
```

```c++
//转方向
class Solution {
public:
    ListNode* reverseList(ListNode* head) 
    {
        ListNode* pre=nullptr;
        ListNode* temp=head;
        ListNode* next;
        while(temp){
            next=temp->next;
            temp->next=pre;
            pre=temp;
            temp=next;
        }
        return pre;
    }
};
```

###  数组中的第K个最大元素（leetcode215）

```c++
给定整数数组 nums 和整数 k，请返回数组中第 k 个最大的元素。
请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。
输入: [3,2,1,5,6,4] 和 k = 2
输出: 5
```

```c++
class Solution {
public:
    int partition(int low,int high,vector<int>& nums)
    {
        if(low>=high) return low;
        int i=low;
        int j=high+1;
        int p=nums[low];
        while(true){
            while(nums[++i]<p){
                if(i==high) break;
            }
            while(nums[--j]>p){
                if(j==low) break;
            }
            if(i>=j) break;
            swap(nums[i],nums[j]);
        }
        swap(nums[low],nums[j]);
        return j;    
    }
    int findKthLargest(vector<int>& nums, int k) 
    {
        int left=0;
        int right=nums.size()-1;
        k=nums.size()-k;
        while(left<=right){
            int p=partition(left,right,nums);
            if(p==k) return nums[p];
            else if(p<k) left=p+1;
            else right=p-1;
        }
        return -1;
    }
};
```

### 二叉树的锯齿形层序遍历(leetcode103)

```c++
    3
   / \
  9  20
    /  \
   15   7

返回锯齿形层序遍历如下：

[
  [3],
  [20,9],
  [15,7]
]
```

```c++
class Solution {
public:
    vector<vector<int>> zigzagLevelOrder(TreeNode* root) 
    {
        vector<vector<int> > res;
        if(root==nullptr) return res;
        deque<TreeNode*> q1;
        q1.push_back(root);
        bool flag=true;
        while(!q1.empty()){
            int size=q1.size();
            vector<int> ans;
            for(int i=0;i<size;++i){
                if(flag){
                    TreeNode* node=q1.front();
                    q1.pop_front();
                    ans.push_back(node->val);
                    if(node->left) q1.push_back(node->left);
                    if(node->right) q1.push_back(node->right);
                }else{
                    TreeNode* node=q1.back();
                    q1.pop_back();
                    ans.push_back(node->val);
                    if(node->right) q1.push_front(node->right);
                    if(node->left) q1.push_front(node->left);
                }
            }
            flag=!flag;
            res.push_back(ans);
        }
        return res;
    }
};
```

### 买卖股票的最佳时机(leetcode121)

```c++
给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。

你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。

输入：[7,1,5,3,6,4]
输出：5
解释：在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。
     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。
```

```c++
class Solution {
public:
    int maxProfit(vector<int>& prices) 
    {
        if(prices.size()==0) return -1;
        int minValue=prices[0];
        int max_profit=0;
        for(int i=1;i<prices.size();++i){
            max_profit=max(max_profit,prices[i]-minValue);
            minValue=min(minValue,prices[i]);
        }
        return max_profit;
    }
};
```

### 链表相交(leetcode160)

```c++
给你两个单链表的头节点 headA 和 headB ，请你找出并返回两个单链表相交的起始节点。如果两个链表没有交点，返回 null 。
```

```c++
class Solution {
public:
    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) 
    {
        ListNode* a=headA;
        ListNode* b=headB;
        while(a!=b){
            a=a==nullptr?headB:a->next;
            b=b==nullptr?headA:b->next;
        }
        return a==nullptr?NULL:a; 
    }
};
```

### 二叉树的最近公共祖先（leetcode236）

```c++
给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。
```

```c++
class Solution {
public:
    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) 
    {
        if(root==nullptr) return nullptr;
        TreeNode* left=lowestCommonAncestor(root->left,p,q);
        TreeNode* right=lowestCommonAncestor(root->right,p,q);
        if(root==p||root==q) return root;
        if(left&&right) return root;
        if(left) return left;
        if(right) return right;
        return nullptr;
    }
};
```

### 接雨水（leecode42）

```c++
输入：height = [0,1,0,2,1,0,1,3,2,1,2,1]
输出：6
解释：上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。
```

```c++
class Solution {
public:
    int trap(vector<int>& height) 
    {
        if(height.size()==0) return 0;
        int leftMax=height[0];
        int rightMax=height[height.size()-1];
        int left=1;
        int right=height.size()-2;
        int res=0;
        while(left<=right){
            if(leftMax<rightMax){
                if(height[left]<leftMax){
                    res+=min(leftMax,rightMax)-height[left];
                }else{
                    leftMax=height[left];
                }
                ++left;
            }else{
                if(height[right]<rightMax){
                    res+=min(leftMax,rightMax)-height[right];
                }else{
                    rightMax=height[right];
                }
                --right;
            }
        }
        return res;
    }
};
```

### 最大子序和(leetcode53)

```c++
给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。
示例 1：
输入：nums = [-2,1,-3,4,-1,2,1,-5,4]
输出：6
解释：连续子数组 [4,-1,2,1] 的和最大，为 6 。
```

```c++
class Solution {
public:
    int maxSubArray(vector<int>& nums) 
    {
        if(nums.size()==0) return 0;
        vector<int> vec(nums.size(),0);
        vec[0]=nums[0];
        int res=nums[0];
        for(int i=1;i<nums.size();++i){
            if(vec[i-1]<=0) vec[i]=nums[i];
            else vec[i]=nums[i]+vec[i-1];
            res=max(res,vec[i]);
        }
        return res;
    }
};
```

### 字符串相加(leetcode415)

```c++
给定两个字符串形式的非负整数 num1 和num2 ，计算它们的和。
```

```c++
class Solution {
public:
    string addStrings(string num1, string num2) 
    {
        int i=num1.size()-1;
        int j=num2.size()-1;
        int temp=0;
        string res;
        while(i>=0||j>=0||temp==1){
            if(i>=0) temp+=num1[i--]-'0';
            if(j>=0) temp+=num2[j--]-'0';
            res+=temp%10+'0';
            temp/=10;
        }
        return string(res.crbegin(),res.crend());
    }
};
```

### 三数之和（leetcode15）

```c++
给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有和为 0 且不重复的三元组。

注意：答案中不可以包含重复的三元组。
    
示例 1：
输入：nums = [-1,0,1,2,-1,-4]
输出：[[-1,-1,2],[-1,0,1]]
```

```c++
class Solution {
public:
    vector<vector<int>> res;
    void twoSum(vector<int>& nums,int start, int target) 
    {
        int right=nums.size()-1;
        int left=start;
        while(left<right){
            int sum=nums[left]+nums[right];
            if(sum==target){
                res.push_back(vector<int>{nums[start-1],nums[left],nums[right]});
               while(left<right&&nums[left]==nums[++left]);
            }
            else if(sum<target) ++left;
            else --right;
        }
        return ;
    }
    vector<vector<int>> threeSum(vector<int>& nums) 
    {
        if(nums.size()<=2) return res;
        sort(nums.begin(),nums.end());
        for(int i=0;i<nums.size();++i){
            if(i>=1&&nums[i]==nums[i-1]) continue;
            twoSum(nums,i+1,-nums[i]);
        }
        return res;
    }
};
```

### 两数之和（leetcode1）

```c++
输入：nums = [2,7,11,15], target = 9
输出：[0,1]
解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。
```

```c++
class Solution {
public:
    vector<int> twoSum(vector<int>& nums, int target) 
    {
        unordered_map<int,int> m1;
        for(int i=0;i<nums.size();++i){
            int num=nums[i];
            if(m1.count(target-num)){
                return vector<int>{m1[target-num],i};
            }else{
                m1[num]=i;
            }
        }
        return vector<int>{};
    }
};
```

### 螺旋矩阵（leetcode54）

```c++
输入：matrix = [[1,2,3],[4,5,6],[7,8,9]]
输出：[1,2,3,6,9,8,7,4,5]
```

```c++
class Solution {
public:
    vector<int> spiralOrder(vector<vector<int>>& matrix) 
    {
        if(matrix.size()==0||matrix[0].size()==0) return vector<int>{};
        vector<int> vec;
        int top=0;
        int bottom=matrix.size()-1;
        int left=0;
        int right=matrix[0].size()-1;
        int i, j;
        while(top<=bottom&&left<=right){
            for(j=left;j<=right;++j){
                vec.push_back(matrix[top][j]);
            }
            ++top;
            if(top>bottom) break;//容易忘记
            for(i=top;i<=bottom;++i){
                vec.push_back(matrix[i][right]);
            }
            --right;
            if(left>right) break;
            for(j=right;j>=left;--j){
                vec.push_back(matrix[bottom][j]);
            }
            --bottom;
            if(top>bottom) break;
            for(i=bottom;i>=top;--i){
                vec.push_back(matrix[i][left]);
            }
            ++left;
            if(left>right) break;
        }
        return vec;
    }
};
```

### 岛屿的数量（leetcode200）

```c++
输入：grid = [
  ["1","1","0","0","0"],
  ["1","1","0","0","0"],
  ["0","0","1","0","0"],
  ["0","0","0","1","1"]
]
输出：3
```

```c++
class Solution {
public:
    void dfs(vector<vector<char>>& grid,int i,int j){
        if(i<0||i>=grid.size()||j<0||j>=grid[0].size()||grid[i][j]=='0') return;
        grid[i][j]='0';
        dfs(grid,i-1,j);
        dfs(grid,i+1,j);
        dfs(grid,i,j-1);
        dfs(grid,i,j+1); 
        return ;
    }
    int numIslands(vector<vector<char>>& grid) 
    {
        if(grid.size()==0||grid[0].size()==0) return 0;
        int res=0;
        for(int i=0;i<grid.size();++i){
            for(int j=0;j<grid[0].size();++j){
                if(grid[i][j]=='1'){
                    grid[i][j]=='0';
                    dfs(grid,i,j);
                    ++res;
                }
            }
        }
        return res;
    }
};
```

### 二叉树的右视图（leetcode199）

```c++
给定一个二叉树的 根节点 root，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。
```

```c++
class Solution {
public:
    vector<int> rightSideView(TreeNode* root) 
    {
        vector<int> vec;
        if(root==nullptr) return vec;
        queue<TreeNode*> q1;
        q1.push(root);
        while(!q1.empty()){
            int size=q1.size();
            int value=0;
            for(int i=0;i<size;++i){
                TreeNode* node=q1.front();
                q1.pop();
                value=node->val;
                if(node->left) q1.push(node->left);
                if(node->right) q1.push(node->right);           
            }
            vec.push_back(value);
        }
        return vec;
    }
};
```

### 下一个排列（leecode31）

```c++
示例 1：
输入：nums = [1,2,3]
输出：[1,3,2]

示例 2：
输入：nums = [3,2,1]
输出：[1,2,3]

示例 3：
输入：nums = [1,1,5]
输出：[1,5,1]
```

```c++
class Solution {
public:
    void nextPermutation(vector<int>& nums) 
    {
        for(int i=nums.size()-1;i>0;--i){
            if(nums[i]>nums[i-1]){
                for(int j=nums.size()-1;j>=i;--j){
                    if(nums[j]>nums[i-1]){
                        swap(nums[j],nums[i-1]);
                        sort(nums.begin()+i,nums.end());
                        return;
                    }
                }
            }
        }
        for(int i=0,j=nums.size()-1;i<j;++i,--j){
            swap(nums[i],nums[j]);
        }
        return ;
    }
};
```

### 最接近的三数之和(leetcode16)

```c++
给定一个包括 n 个整数的数组 nums 和 一个目标值 target。找出 nums 中的三个整数，使得它们的和与 target 最接近。返回这三个数的和。假定每组输入只存在唯一答案。
示例：

输入：nums = [-1,2,1,-4], target = 1
输出：2
解释：与 target 最接近的和是 2 (-1 + 2 + 1 = 2) 。
```

```c++
class Solution {
public:
    int threeSumClosest(vector<int>& nums, int target) {
        if(nums.size()==3){
            return nums[0]+nums[1]+nums[2];
        }
        sort(nums.begin(),nums.end());
        int res=0;
        int minValue=INT_MAX;
        for(int i=0;i<nums.size();++i){
            int begin=i+1;
            int end=nums.size()-1;
            while(begin<end){
                if(nums[begin]+nums[end]==target-nums[i]) 
                    return nums[begin]+nums[end]+nums[i];
                if(abs(nums[begin]+nums[end]+nums[i]-target)<minValue){
                    res=nums[begin]+nums[end]+nums[i];
                    minValue=abs(nums[begin]+nums[end]+nums[i]-target);   
                }
                if(nums[begin]+nums[end]>target-nums[i]) --end;
                else ++begin; 
            }
        }
        return res;
    }
};
```

## 腾讯

### 用 Rand7() 实现 Rand10()(leetcode470)

```c++
class Solution {
public:
    int rand10() 
    {
        int num=41;
        while(num>40){
            num=(rand7()-1)*7+rand7();
        }    
        return (num-1)%10+1;
    }
};
```



# 回溯算法（backtracking）

算法框架：

```cpp
result = []
def backtrack(路径, 选择列表):
    if 满足结束条件:
        result.add(路径)
        return

    for 选择 in 选择列表:
        做选择
        backtrack(路径, 选择列表)
        撤销选择
```

 **我们只要在递归之前做出选择，在递归之后撤销刚才的选择** 

```cpp
for 选择 in 选择列表:
    # 做选择 
    将该选择从选择列表移除
    路径.add(选择)
    backtrack(路径, 选择列表)
    # 撤销选择
    路径.remove(选择)
    将该选择再加入选择列表
```

## *全排列（leetcode46）

```java
List<List<Integer>> res = new LinkedList<>();

/* 主函数，输入一组不重复的数字，返回它们的全排列 */
List<List<Integer>> permute(int[] nums) {
    // 记录「路径」
    LinkedList<Integer> track = new LinkedList<>();
    backtrack(nums, track);
    return res;
}

// 路径：记录在 track 中
// 选择列表：nums 中不存在于 track 的那些元素
// 结束条件：nums 中的元素全都在 track 中出现
void backtrack(int[] nums, LinkedList<Integer> track) {
    // 触发结束条件
    if (track.size() == nums.length) {
        res.add(new LinkedList(track));
        return;
    }
    for (int i = 0; i < nums.length; i++) {
        // 排除不合法的选择
        if (track.contains(nums[i]))
            continue;
        // 做选择
        track.add(nums[i]);
        // 进入下一层决策树
        backtrack(nums, track);
        // 取消选择
        track.removeLast();
    }
}
```

全排列的改进：用交换元素。start位置之前已经交换好了，将start和后面所有位置进行一遍交换

```cpp
class Solution {
public:
    vector<vector<int>> ans;
    vector<vector<int>> permute(vector<int>& nums) {
        permute1(nums, 0);
        return ans;
    }
    void permute1(vector<int>& nums, int start) {
        if (start == nums.size()) {
            ans.push_back(nums);
            return;
        }
        for (int i = start; i < nums.size(); ++i) {
            swap(nums[start], nums[i]);
            permute1(nums, start + 1);
            swap(nums[start], nums[i]);
        }
        return;
    }
};
```

## N皇后问题（leetcode51）

和全排列一样，交换前把行不通的路径排除掉.

```CPP
class Solution {
public:
    vector<vector<string>> res;
    vector<vector<string>> solveNQueens(int n) {
        vector<string> paths(n,string(n,'.'));
        dfs(paths,0,n);
        return res;
    }
    void dfs(vector<string>& paths,int end,int n){
        if(end==n){
            res.push_back(paths);
        }        
        for(int i=0;i<n;++i){
            if(!isvaild(paths,end,n,i)) continue;//交换前把行不通的路径排除掉
            paths[end][i]='Q';
            dfs(paths,end+1,n);
            paths[end][i]='.';
        }
        return ;
    }
    //交换前把行不通的路径排除掉
    bool isvaild(vector<string>& paths,int end,int n,int i)
    {
        for(int j=0;j<=end;++j){
            if(paths[j][i]=='Q') return false;
        }
        for(int j=0;j<=end;++j){
            for(int k=0;k<n;++k){
                if(paths[j][k]=='Q'){
                    int a=k+end-j;
                    if(a<=n-1&&a==i) return false;
                    int b=k+j-end;
                    if(b>=0&&b==i) return false;
                }
            }
        }
        return true;
    }
};
```

## 电话号码的字母组合（leetcode17）

传统的回溯算法

```cpp
输入：digits = "23"
输出：["ad","ae","af","bd","be","bf","cd","ce","cf"]
```

```c++
class Solution {
public:
    vector<string> letterCombinations(string digits) 
    {
        if(digits.size()==0) return vector<string>{};
        unordered_map<int,string> m1{{2,"abc"},{3,"def"},{4,"ghi"},{5,"jkl"},{6,"mno"},{7,"pqrs"},{8,"tuv"},{9,"wxyz"}};
        vector<string> ans;
        string res;
        backtracking(res,ans,m1,digits,0);
        return ans;
    }
    void backtracking(string& res,vector<string>& ans,unordered_map<int,string>& m1,string digits,int start){
        if(start==digits.size()){
            ans.push_back(res);
            return;
        }
        string str=m1[digits[start]-'0'];
        for(int i=0;i<str.size();++i){
            res.push_back(str[i]);
            backtracking(res,ans,m1,digits,start+1);
            res.pop_back();
        }
        return;
    }
};
```

## 二叉树的所有路径（leetcode257）

```c++
输入:

   1
 /   \
2     3
 \
  5

输出: ["1->2->5", "1->3"]
```

```c++
class Solution {
public:
    vector<string> binaryTreePaths(TreeNode* root) 
    {
        vector<string> res;
        string str;
        dfs(root,res,str);
        return res;
    }
    void  dfs(TreeNode* root,vector<string>& res,string str){
        if(root==nullptr) return ;
        if(root&&root->left==nullptr&&root->right==nullptr){
            str+=to_string(root->val);
            res.push_back(str);
        }
        str+=to_string(root->val);
        str+="->";
        dfs(root->left,res,str);
        dfs(root->right,res,str);
        return ;
    }
};
```

## 复原IP地址（leetcode93）

注意剪枝和判断有效性

```c++
输入：s = "101023"
输出：["1.0.10.23","1.0.102.3","10.1.0.23","10.10.2.3","101.0.2.3"]
```

```c++
class Solution {
public:
    vector<string> restoreIpAddresses(string s) 
    {
        vector<string> res;
        if(s.size()<4||s.size()>12) return res;//剪枝
        vector<int> paths;
        backtracking(s,res,paths,0);
        return res;
    }    

    void backtracking(string s,vector<string>& res,vector<int>& paths,int start)
    {
        if(paths.size()==3){
            string path;
            auto pre=s.begin();
            for(int i=0;i<3;++i){
                auto next=s.begin()+paths[i];
                string str(pre,next);
                if(judgeIpSegment(str)){
                    path+=str;
                    path+='.';
                }
                else return;
                pre=next;
            }
            string str(pre,s.end());
            if(judgeIpSegment(str)) path+=str;
            else  return;
            res.push_back(path);            
            return ;
        }
        for(int i=start+1;i<s.size();++i){
            if(!paths.empty()&&i-paths.back()>3) continue;//剪枝
            if(paths.empty()&&i>3) continue;//剪枝
            paths.push_back(i);
            backtracking(s,res,paths,i);
            paths.pop_back();
        }
    }
	//判断str有效性
    bool judgeIpSegment(string str) {
        if (str.size() > 1 && str[0]== '0') {
            return false;
        }
        int res=0;
        int pos = 0;
        while (pos<str.size()) {
            res = res * 10 + str[pos] - '0';
            pos++;
        }
        return res >= 0 && res <= 255;
    }
};
```

## *子集（leetcode78）

子集按顺序，记得添加 start.

```c++
输入：nums = [1,2,3]
输出：[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]
```

```c++
class Solution {
public:
    vector<vector<int>> subsets(vector<int>& nums) 
    {
        vector<vector<int>> res;
        vector<int> ans;
        dfs(nums,res,ans,0);
        return res;
    }
    void dfs(vector<int>& nums,vector<vector<int>>& res,vector<int>& ans,int start)
    {
        res.push_back(ans);
        for(int i=start;i<nums.size();++i){
            ans.push_back(nums[i]);
            dfs(nums,res,ans,i+1);
            ans.pop_back();
        }
        return ;
    }
};
```

## 子集II（leetcode90）

和子集不同的是有重复元素的，要排序+去重. 

排序：使相同的数字在一起

去重：start必选，if (start>i &&nums[i]==nums[i-1])  continue；

```c++
输入：nums = [1,2,2]
输出：[[],[1],[1,2],[1,2,2],[2],[2,2]]
```

```c++
class Solution {
public:
    vector<vector<int>> subsetsWithDup(vector<int>& nums) 
    {
        sort(nums.begin(),nums.end()); //排序，使相同的数字在一起
        vector<vector<int>> res;
        vector<int> ans;
        dfs(nums,res,ans,0);
        return res;
    }
    void dfs(vector<int>& nums,vector<vector<int>>& res,vector<int>& ans,int start)
    {
        res.push_back(ans);
        for(int i=start;i<nums.size();++i){
            if(start>i&&nums[i]==nums[i-1]) continue; //重点
            ans.push_back(nums[i]);
            dfs(nums,res,ans,i+1);
            ans.pop_back();
        }
        return ;
    }
};
```

## *组合（leetcode77）

```c++
输入: n = 4, k = 2
输出:
[ [2,4],
  [3,4],
  [2,3],
  [1,2],
  [1,3],
  [1,4],]
```

```c++
class Solution {
public:
    vector<vector<int>> combine(int n, int k) 
    {
        vector<vector<int>> res;
        vector<int> ans ;
        dfs(res,ans,k,1,n);
        return res;
    }
    void dfs(vector<vector<int>>& res,vector<int>& ans,int k,int start,int n)
    {
        if(ans.size()==k){
            res.push_back(ans);
        }
        for(int i=start;i<=n;++i){
            ans.push_back(i);
            dfs(res,ans,k,i+1,n);
            ans.pop_back();
        }
        return;
    }
};
```

## 组合总和（leetcode39）

```c++
输入：candidates = [2,3,6,7], target = 7,
所求解集为：
[[7],
 [2,2,3]]
```

```c++
class Solution {
public:
    vector<vector<int>> combinationSum(vector<int>& candidates, int target) 
    {
        vector<vector<int>> res;
        vector<int> ans;
        dfs(candidates,res,ans,target,0);
        return res;
    }
    void dfs(vector<int>& candidates,vector<vector<int>>& res,vector<int>& ans,int target,int start)
    {
        if(target==0){
            res.push_back(ans);
            return ;
        }
        if(target<0) return;
        for(int i=start;i<candidates.size();++i){
            ans.push_back(candidates[i]);
            dfs(candidates,res,ans,target-candidates[i],i);//可重复选择则 i,不可重复选择则 i+1 
            ans.pop_back();
        }
        return ;
    }
};
```

## 组合总和II（leetcode40）

有重复元素的

去重：start必选，if (start>i &&nums[i]==nums[i-1])  continue；

```c++
输入: candidates = [10,1,2,7,6,1,5], target = 8,
所求解集为:
[ [1, 7],
  [1, 2, 5],
  [2, 6],
  [1, 1, 6]]
```

```c++
class Solution {
public:
    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) 
    {
        sort(candidates.begin(),candidates.end()); //重点
        vector<vector<int>> res;
        vector<int> ans;
        dfs(candidates,res,ans,target,0);
        return res;
    }
    void dfs(vector<int>& candidates,vector<vector<int>>& res,vector<int>& ans,int target,int start)
    {
        if(target==0){
            res.push_back(ans);
            return ;
        }
        if(target<0) return;
        for(int i=start;i<candidates.size();++i){
            if(i>start&&candidates[i]==candidates[i-1]) continue; //重点
            ans.push_back(candidates[i]);
            dfs(candidates,res,ans,target-candidates[i],i+1);
            ans.pop_back();
        }
        return ;
    }
};
```

## 组合总和III（leetcode216）

```c++
找出所有相加之和为 n 的 k 个数的组合。组合中只允许含有 1 - 9 的正整数，并且每种组合中不存在重复的数字。
输入: k = 3, n = 9
输出: [[1,2,6], [1,3,5], [2,3,4]]
```

```c++
class Solution {
public:
    vector<vector<int>> combinationSum3(int k, int n) {
        vector<vector<int>> res;
        vector<int> ans;
        dfs(res,ans,n,k,1);
        return res;
    }
    void dfs(vector<vector<int>>& res,vector<int>& ans,int n,int k,int start)
    {
        if(k==0&&n==0){
            res.push_back(ans);
            return ;
        }
        for(int i=start;i<=9;++i){
            ans.push_back(i);
            dfs(res,ans,n-i,k-1,i+1);
            ans.pop_back();
        }        
        return ;
    }
};
```

# DFS

## *岛屿的最大面积（leetcode695）

```c++
输入:
[[0,0,1,0,0,0,0,1,0,0,0,0,0],
 [0,0,0,0,0,0,0,1,1,1,0,0,0],
 [0,1,1,0,1,0,0,0,0,0,0,0,0],
 [0,1,0,0,1,1,0,0,1,0,1,0,0],
 [0,1,0,0,1,1,0,0,1,1,1,0,0],
 [0,0,0,0,0,0,0,0,0,0,1,0,0],
 [0,0,0,0,0,0,0,1,1,1,0,0,0],
 [0,0,0,0,0,0,0,1,1,0,0,0,0]]
输出: 6
```

```c++
class Solution {
public:
    int maxAreaOfIsland(vector<vector<int>>& grid) 
    {
        int n=grid.size();
        if(n==0) return 0;
        int m=grid[0].size();
        int res=0;
        for(int i=0;i<n;++i)
        {
            for(int j=0;j<m;++j)
            {
                if(grid[i][j]==1){
                    int count=0;
                    dfs(grid,i,j,n,m,count);
                    res=max(res,count);
                }
            }
        }
        return res;
    }
    void dfs(vector<vector<int>>& grid,int i,int j,int n,int m,int& count)
    {
        if(i<0||i>=n||j<0||j>=m||grid[i][j]==0) return;//记住先判断边界，再正确的下标下判断内容
        grid[i][j]=0;
        ++count;
        dfs(grid,i+1,j,n,m,count);
        dfs(grid,i,j+1,n,m,count);
        dfs(grid,i-1,j,n,m,count);
        dfs(grid,i,j-1,n,m,count);
        return ;
    }
};
```

## 岛屿数量（leetcode200）

和上面一题一模一样.面试题

```c++
输入：grid = [
  ["1","1","1","1","0"],
  ["1","1","0","1","0"],
  ["1","1","0","0","0"],
  ["0","0","0","0","0"]
]
输出：1
```

```c++
class Solution {
public:
    int numIslands(vector<vector<char>>& grid) 
    {
        int n=grid.size();
        if(n==0) return 0;
        int m=grid[0].size();
        int res=0;
        for(int i=0;i<n;++i)
        {
            for(int j=0;j<m;++j)
            {
                if(grid[i][j]=='1'){
                    dfs(grid,i,j,n,m);
                    ++res;
                }
            }
        }
        return res;
    }
    void dfs(vector<vector<char>>& grid,int i,int j,int n,int m)
    {
        if(i<0||i>=n||j<0||j>=m||grid[i][j]=='0') return;
        grid[i][j]='0';
        dfs(grid,i+1,j,n,m);
        dfs(grid,i,j+1,n,m);
        dfs(grid,i-1,j,n,m);
        dfs(grid,i,j-1,n,m);
        return ;
    }
};
```

## *省份数量（leetcode547）

```c++
思路： 用一个used记录遍历的省
```

```c++
输入：isConnected = [[1,0,0,1],
                     [0,1,1,0],
                     [0,1,1,1],
                     [1,0,1,1]]
输出：1
```

```c++
class Solution {
public:
    int findCircleNum(vector<vector<int>>& isConnected) {
        int n=isConnected.size();
        if(n==0) return 0;
        int res=0;
        vector<int> used(n,0);
        for(int i=0;i<n;++i)//遍历每个省
        {
            if(used[i]==0)  //进入新朋友圈
            {
                dfs(isConnected,used,i,n);
                ++res;
            }
        }
        return res;
    }
    void dfs(vector<vector<int>>& isConnected,vector<int>& used,int i,int n)
    {
        used[i]=1;           //遍历过的加入used中
        for(int j=0;j<n;++j) //遍历每个省的朋友
        {
            if(used[j]==0&&isConnected[i][j]==1)
            {
                dfs(isConnected,used,j,n);
            }
        }
        return ;
    }
};
```

## 被围绕的区域（leetcode130）

```C++
输入：board = [["X","X","X","X"],["X","O","O","X"],["X","X","O","X"],["X","O","X","X"]]
输出：[["X","X","X","X"],["X","X","X","X"],["X","X","X","X"],["X","O","X","X"]]
解释：被围绕的区间不会存在于边界上，换句话说，任何边界上的 'O' 都不会被填充为 'X'。 任何不在边界上，或不与边界上的 'O' 相连的 'O' 最终都会被填充为 'X'。如果两个元素在水平或垂直方向相邻，则称它们是“相连”的。
```

```c++
思路：从边缘开始搜寻
```

```C++
class Solution {
public:
    void solve(vector<vector<char>>& board) 
    {
        int n=board.size();
        if(n==0) return ;
        int m=board[0].size();
        for(int i=0;i<n;++i)
        {
            for(int j=0;j<m;++j)
            {
                if(i==0||j==0||i==n-1||j==m-1)  //边缘搜寻
                {
                    if(board[i][j]=='O'){
                        dfs(board,i,j,n,m);                    
                    }
                }
            }
        }
        for(int x=0;x<n;++x){
            for(int y=0;y<m;++y){ //外部连通的“O”,则保持变回原来的“O”，内部的“O”,则变成“X”;
                if(board[x][y]=='+'){
                    board[x][y]='O';
                }else if(board[x][y]=='O'){
                    board[x][y]='X';
                }
            }
        }
        return ;
    }
    void dfs(vector<vector<char>>& board,int i,int j,int n,int m)
    {
        if(i<0||i>=n||j<0||j>=m||board[i][j] == 'X'||board[i][j] == '+') return;
        board[i][j]='+';  //外部连通的“O”变号
        dfs(board,i+1,j,n,m);
        dfs(board,i-1,j,n,m);
        dfs(board,i,j+1,n,m);
        dfs(board,i,j-1,n,m);
        return ;
    }
};
```

# BFS

​		**1.BFS是用来搜索最短径路的解是比较合适的**，比如求最少步数的解，最少交换次数的解，因为BFS搜索过程中遇到的解一定是离根最近的，所以遇到一个解，一定就是最优解，此时搜索算法可以终止.
 		这个时候不适宜使用DFS，**因为DFS搜索到的解不一定是离根最近的，只有全局搜索完毕，才能从所有解中找出离根的最近的解.**

​       **2.**空间优劣上，DFS是有优势的，DFS不需要保存搜索过程中的状态,**而BFS在搜索过程中需要保存搜索过的状态，**而且一般情况需要一个队列来记录 

​       **3.**DFS适合搜索全部的解，因为要搜索全部的解，那么BFS搜索过程中，遇到离根最近的解，并没有什么用，所以搜素全部解的问题，DFS显然更加合适。

## 二进制矩阵中的最短路径（leetcode1091）

```c++
给你一个 n x n 的二进制矩阵 grid 中，返回矩阵中最短 畅通路径 的长度。如果不存在这样的路径，返回 -1 。

二进制矩阵中的 畅通路径 是一条从 左上角 单元格（即，(0, 0)）到 右下角 单元格（即，(n - 1, n - 1)）的路径，该路径同时满足下述要求：

    路径途经的所有单元格都的值都是 0 。
    路径中所有相邻的单元格应当在 8 个方向之一 上连通（即，相邻两单元之间彼此不同且共享一条边或者一个角）。
    
畅通路径的长度 是该路径途经的单元格总数.
```

```c++
class Solution {
public:
    int shortestPathBinaryMatrix(vector<vector<int>>& grid) 
    {
        int n=grid.size();
        if(n==0||grid[n-1][n-1]==1||grid[0][0]==1) return -1;
        vector<pair<int,int>> dir{{-1,0},{-1,-1},{0,-1},{-1,1},{0,1},{1,0},{1,-1},{1,1}};
        queue<pair<int,int>> q1;
        q1.push({0,0});
        int res=1;
        while(!q1.empty()){
            int count=q1.size();
            for(int i=0;i<count;++i){
                pair<int,int> temp=q1.front();
                q1.pop();
                int x=temp.first;
                int y=temp.second;
                if(x==n-1&&y==n-1) return res;
                for(auto d:dir){
                    int nx=x+d.first;
                    int ny=y+d.second;
                    if(nx<0||ny<0||nx>=n||ny>=n||grid[nx][ny]==1) continue;
                    grid[nx][ny]=1;
                    q1.push({nx,ny});
                }
            }
            ++res;
        }
        return -1;
    }
};
```

# 二叉树

## 二叉树的最大深度（leetcode104)

```c++
给定一个二叉树，找出其最大深度。
二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。
说明: 叶子节点是指没有子节点的节点。
示例：
给定二叉树 [3,9,20,null,null,15,7]，

    3
   / \
  9  20
    /  \
   15   7

返回它的最大深度 3 。
```

```c++
class Solution {
public:
    int maxDepth(TreeNode* root) 
    {
        if(root==nullptr) return 0;
        int left=maxDepth(root->left);
        int right=maxDepth(root->right);
        return 1+max(left,right);
   }
};
```

## 平衡二叉树（leetcode110)

```c++
给定一个二叉树，判断它是否是高度平衡的二叉树。
本题中，一棵高度平衡二叉树定义为：

一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1 
```

```c++
class Solution {
public:
    int dfs(TreeNode* root){
        if(root==nullptr) return 0;
        int left=dfs(root->left);
        int right=dfs(root->right);
        if(left==-1||right==-1) return -1;
        if(abs(left-right)>1) return -1;
        return 1+max(left,right);
    }
    bool isBalanced(TreeNode* root) 
    {
        if(root==nullptr) return true;
        return dfs(root)!=-1;
    }
};
```

## 二叉树的直径（leetcode543)

```c++
给定一棵二叉树，你需要计算它的直径长度。一棵二叉树的直径长度是任意两个结点路径长度中的最大值。这条路径可能穿过也可能不穿过根结点。
示例 :
给定二叉树
          1
         / \
        2   3
       / \     
      4   5  
返回 3, 它的长度是路径 [4,2,1,3] 或者 [5,2,1,3]。
```

```c++
class Solution {
public:
    int maxValue=0;
    int dfs(TreeNode* root)
    {
        if(root==nullptr) return 0;
        int left=dfs(root->left);
        int right=dfs(root->right);
        maxValue=max(maxValue,left+right);
        return max(left,right)+1;
    }
    int diameterOfBinaryTree(TreeNode* root) 
    {
        if(root==nullptr) return 0;
        dfs(root);
        return maxValue;
    }
};
```

## 翻转二叉树（leetcode543)

```c++
class Solution {
public:
    TreeNode* invertTree(TreeNode* root) 
    {
        if(root==nullptr) return nullptr;
        TreeNode* temp=invertTree(root->left);
        root->left=invertTree(root->right);
        root->right=temp;
        return root;
    }
};
```

## 合并二叉树（leetcode617)

```c++
给定两个二叉树，想象当你将它们中的一个覆盖到另一个上时，两个二叉树的一些节点便会重叠。

你需要将他们合并为一个新的二叉树。合并的规则是如果两个节点重叠，那么将他们的值相加作为节点合并后的新值，否则不为 NULL 的节点将直接作为新二叉树的节点。

示例 1:

输入: 
	Tree 1                     Tree 2                  
          1                         2                             
         / \                       / \                            
        3   2                     1   3                        
       /                           \   \                      
      5                             4   7                  
输出: 
合并后的树:
	     3
	    / \
	   4   5
	  / \   \ 
	 5   4   7
```

```c++
class Solution {
public:
    TreeNode* mergeTrees(TreeNode* root1, TreeNode* root2) 
    {
        if(root1==nullptr&&root2==nullptr) return nullptr;
        int val1=root1==nullptr?0:root1->val;
        int val2=root2==nullptr?0:root2->val;
        TreeNode* newNode=new TreeNode(val1+val2);
        newNode->left=mergeTrees(root1?root1->left:nullptr,root2?root2->left:nullptr);
        newNode->right=mergeTrees(root1?root1->right:nullptr,root2?root2->right:nullptr);
        return newNode;
    }
};
```

```java
public TreeNode mergeTrees(TreeNode t1, TreeNode t2) {
    if (t1 == null && t2 == null) return null;
    if (t1 == null) return t2;
    if (t2 == null) return t1;
    TreeNode root = new TreeNode(t1.val + t2.val);
    root.left = mergeTrees(t1.left, t2.left);
    root.right = mergeTrees(t1.right, t2.right);
    returnoot;
}
```

## 路径总和（leetcode112)

```c++
给你二叉树的根节点 root 和一个表示目标和的整数 targetSum ，判断该树中是否存在 根节点到叶子节点 的路径，这条路径上所有节点值相加等于目标和 targetSum 。

叶子节点 是指没有子节点的节点。
```

```c++
class Solution {
public:
    bool hasPathSum(TreeNode* root, int targetSum) {
        if(root==nullptr) return false;
        if(root->left==nullptr&&root->right==nullptr&&targetSum==root->val) return true;
        targetSum-=root->val;
        return hasPathSum(root->left,targetSum)||hasPathSum(root->right,targetSum);
    }
};
```

## 路径总和III（leetcode437)

```c++
root = [10,5,-3,3,2,null,11,3,-2,null,1], sum = 8

      10
     /  \
    5   -3
   / \    \
  3   2   11
 / \   \
3  -2   1

返回 3。和等于 8 的路径有:
1.  5 -> 3
2.  5 -> 2 -> 1
3.  -3 -> 11
```

```c++
class Solution {
public:
    int res=0;
    void dfs1(TreeNode* root,int targetSum)
    {
        if(root==nullptr) return ;
        if(targetSum==root->val){
            ++res;
        }
        targetSum-=root->val;
        dfs1(root->left,targetSum);
        dfs1(root->right,targetSum);
        return;
    }
    void dfs(TreeNode* root,int targetSum)
    {
        if(root==nullptr) return ;
        dfs(root->left,targetSum);
        dfs(root->right,targetSum);
        dfs1(root,targetSum);
        return;
    }
    int pathSum(TreeNode* root, int targetSum) 
    {
        if(root==nullptr) return 0;
        dfs(root,targetSum);
        return res;
    }
};
```

## 另一个树的子树(leetcode572)

```c++
给定两个非空二叉树 s 和 t，检验 s 中是否包含和 t 具有相同结构和节点值的子树。s 的一个子树包括 s 的一个节点和这个节点的所有子孙。s 也可以看做它自身的一棵子树。

示例 1:
给定的树 s:

     3
    / \
   4   5
  / \
 1   2

给定的树 t：

   4 
  / \
 1   2
```

```c++
class Solution {
public:
    bool isSame(TreeNode* root,TreeNode* subRoot)
    {
        if(root==nullptr&&subRoot==nullptr) return true;
        if(root==nullptr||subRoot==nullptr||root->val!=subRoot->val) return false;
        return isSame(root->left,subRoot->left)&&isSame(root->right,subRoot->right);
    }
    bool isSubtree(TreeNode* root, TreeNode* subRoot) 
    {
        if(root==nullptr) return false;
        return isSubtree(root->left,subRoot)||isSubtree(root->right,subRoot)||isSame(root,subRoot);
    }
};
```

## 对称二叉树（leetcode101)

```c++
给定一个二叉树，检查它是否是镜像对称的。
例如，二叉树 [1,2,2,3,4,4,3] 是对称的。

    1
   / \
  2   2
 / \ / \
3  4 4  3
但是下面这个 [1,2,2,null,3,null,3] 则不是镜像对称的:

    1
   / \
  2   2
   \   \
   3    3
```

```c++
class Solution {
public:
    bool isSame(TreeNode* root1,TreeNode* root2){
        if(root1==nullptr&&root2==nullptr) return true;
        if(root1==nullptr||root2==nullptr||root1->val!=root2->val) return false;
        return isSame(root1->left,root2->right)&&isSame(root1->right,root2->left);
    }
    bool isSymmetric(TreeNode* root) 
    {
        if(root==nullptr) return false;
        return isSame(root->left,root->right);
    }
};
```

## 二叉树的最小深度（leetcode111)

```c++
给定一个二叉树，找出其最小深度。
最小深度是从根节点到最近叶子节点的最短路径上的节点数量。
说明：叶子节点是指没有子节点的节点。
示例 1：

输入：root = [3,9,20,null,null,15,7]
输出：2
```

```c++
class Solution {
public:
    int minDepth(TreeNode* root) 
    {
       if(root==nullptr) return 0;
       int left =minDepth(root->left);
       int right =minDepth(root->right);
       if(right==0) return left+1;
       if(left==0) return right+1;
       return min(left,right)+1;
    }
};
```

## 左叶子之和（leetcode404）

```c++
计算给定二叉树的所有左叶子之和。

示例：

    3
   / \
  9  20
    /  \
   15   7

在这个二叉树中，有两个左叶子，分别是 9 和 15，所以返回 24
```

```c++
class Solution {
public:
    void dfs(TreeNode* root,int &value)
    {
        if(root==nullptr) return;
        if(root->left&&root->left->right==nullptr&&root->left->left==nullptr) value+=root->left->val;
        dfs(root->left,value);
        dfs(root->right,value);
        return ;
    }
    int sumOfLeftLeaves(TreeNode* root) 
    {
        if(root==nullptr) return 0;
        int value=0;
        dfs(root,value);
        return value;
    }
};
```

## 最长同值路径（leetcode687）

```c++
给定一个二叉树，找到最长的路径，这个路径中的每个节点具有相同值。 这条路径可以经过也可以不经过根节点。
注意：两个节点之间的路径长度由它们之间的边数表示。
示例 1:
输入:
              5
             / \
            4   5
           / \   \
          1   1   5

输出:
2
```

```c++
class Solution {
public:
    int maxValue=0;
    int dfs(TreeNode* root){
        if(root==nullptr) return 0;
        int left=dfs(root->left);
        int right=dfs(root->right);
        int lp=root->left&&root->left->val==root->val?left:0;
        int rp=root->right&&root->right->val==root->val?right:0;
        maxValue=max(maxValue,lp+rp);
        return max(lp,rp)+1;
    }
    int longestUnivaluePath(TreeNode* root) 
    {
        if(root==nullptr) return 0;
        dfs(root);
        return maxValue;
    }
};
```

## 打家劫舍III（leetcode337）

```c++
在上次打劫完一条街道之后和一圈房屋后，小偷又发现了一个新的可行窃的地区。这个地区只有一个入口，我们称之为“根”。 除了“根”之外，每栋房子有且只有一个“父“房子与之相连。一番侦察之后，聪明的小偷意识到“这个地方的所有房屋的排列类似于一棵二叉树”。 如果两个直接相连的房子在同一天晚上被打劫，房屋将自动报警。

计算在不触动警报的情况下，小偷一晚能够盗取的最高金额。

示例 1:

输入: [3,2,3,null,3,null,1]

     3
    / \
   2   3
    \   \ 
     3   1

输出: 7 
解释: 小偷一晚能够盗取的最高金额 = 3 + 3 + 1 = 7.
```

```c++
class Solution {
public:
    int rob(TreeNode* root) 
    {
        if(root==nullptr) return 0;
        int value1=root->val;
        if(root->left) value1=value1+rob(root->left->left)+rob(root->left->right);
        if(root->right) value1=value1+rob(root->right->left)+rob(root->right->right);
        int value2=rob(root->left)+rob(root->right);
        return max(value1,value2);
    }
};
```

## 二叉树中第二小的节点(leetcode671)

```c++
给定一个非空特殊的二叉树，每个节点都是正数，并且每个节点的子节点数量只能为 2 或 0。如果一个节点有两个子节点的话，那么该节点的值等于两个子节点中较小的一个。

更正式地说，root.val = min(root.left.val, root.right.val) 总成立。

给出这样的一个二叉树，你需要输出所有节点中的第二小的值。如果第二小的值不存在的话，输出 -1 。
示例 1：

输入：root = [2,2,5,null,null,5,7]
输出：5
解释：最小的值是 2 ，第二小的值是 5 。
```

```c++
public:
    int findSecondMinimumValue(TreeNode* root) 
    {
        if(root==nullptr||root->left==nullptr) return -1;
        int left=root->left->val;
        int right=root->right->val;
        if(left==root->val) left=findSecondMinimumValue(root->left);
        if(right==root->val) right=findSecondMinimumValue(root->right);
        if(left!=-1&&right!=-1) return min(left,right);
        if(left!=-1) return left;
        return right;
    }
};
```



# 二分法

```c++
while(left<=right) 则跳出后 [right][left]的相对位置 ,寻找左边沿的前一个用right，寻找右边沿的后一个用left
寻找左边沿，==mid,right=mid-1,最后用left
寻找右边沿，==mid,left=mid+1,最后用right 
```

## *二分查找（leetcode704)

```c++
给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target  ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。

示例 1:

输入: nums = [-1,0,3,5,9,12], target = 9
输出: 4
解释: 9 出现在 nums 中并且下标为 4
```

```c++
class Solution {
public:
    int search(vector<int>& nums, int target) 
    {
        int left=0;
        int right=nums.size()-1;
        while(left<=right){
            int mid =left+(right-left)/2;
            if(nums[mid]==target) return mid;
            else if(nums[mid]<target) left=mid+1;
            else if(nums[mid]>target) right=mid-1;
        }
        return -1;
    }
};
```

## *在排序数组中查找元素的第一个和最后一个位置（leetcode34)

```c++
给定一个按照升序排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置。
如果数组中不存在目标值 target，返回 [-1, -1]。

示例 1：
输入：nums = [5,7,7,8,8,10], target = 8
输出：[3,4]
```

```c++
class Solution {
public:
    vector<int> searchRange(vector<int>& nums, int target) 
    {
        if(nums.size()==0) return vector<int>{-1,-1};
        int left=searchLeftIndex(nums, target);
        int right=searchRightIndex(nums, target);
        return vector<int>{left,right};
    }
    int searchLeftIndex(vector<int>& nums,int target)
    {
        int left=0;
        int right=nums.size()-1;
        while(left<=right){
            int mid=left+(right-left)/2;
            if(nums[mid]==target) right=mid-1;
            else if(nums[mid]<target) left=mid+1;
            else if(nums[mid]>target) right=mid-1;
        }
        if(left<nums.size()&&nums[left]==target) return left;
        return -1;
    }
    int searchRightIndex(vector<int>& nums,int target)
    {
        int left=0;
        int right=nums.size()-1;
        while(left<=right){
            int mid=left+(right-left)/2;
            if(nums[mid]==target) left=mid+1;
            else if(nums[mid]<target) left=mid+1;
            else if(nums[mid]>target) right=mid-1;
        }
        if(right>=0&&nums[right]==target) return right;
        return -1;
    }
};
```

## x 的平方根（leetcode69)

```c++
实现 int sqrt(int x) 函数。
计算并返回 x 的平方根，其中 x 是非负整数。
由于返回类型是整数，结果只保留整数的部分，小数部分将被舍去。

示例 1:
输入: 4
输出: 2
```

```c++
class Solution {
public:
    int mySqrt(int x) 
    {
        int left=1;
        int right=x;
        while(left<=right){
            int mid=left+(right-left)/2;
            int sqrt = x / mid;
            if(sqrt==mid) return mid;
            else if(sqrt>mid) left=mid+1;
            else if(sqrt<mid) right=mid-1;
        }
        return right;
    }
};
```

## 寻找比目标字母大的最小字母（leetcode744)

```c++
给你一个排序后的字符列表 letters ，列表中只包含小写英文字母。另给出一个目标字母 target，请你寻找在这一有序列表里比目标字母大的最小字母。
在比较时，字母是依序循环出现的。举个例子：
    如果目标字母 target = 'z' 并且字符列表为 letters = ['a', 'b']，则答案返回 'a' 

示例：
输入:
letters = ["c", "f", "j"]
target = "a"
输出: "c"
```

```c++
class Solution {
public:
    char nextGreatestLetter(vector<char>& letters, char target) 
    {
        int left=0;
        int right=letters.size()-1;
        while(left<=right){
            int mid=left+(right-left)/2;
            char c=letters[mid];
            if(c==target) left=mid+1;
            else if(c>target) right=mid-1;
            else if(c<target) left=mid+1;
        }
        return left<letters.size()?letters[left]:letters[0];
    }
};
```

## 有序数组中的单一元素（leetcode540)

```c++
给定一个只包含整数的有序数组，每个元素都会出现两次，唯有一个数只会出现一次，找出这个数。

示例 1:
输入: [1,1,2,3,3,4,4,8,8]
输出: 2
```

```c++
class Solution {
public:
    int singleNonDuplicate(vector<int>& nums) 
    {
        int left=0;
        int right=nums.size()-1;
        while(left<right)
        {
            int mid=left+(right-left)/2;
            if(mid%2==1) mid--;
            if(nums[mid]==nums[mid+1]) left=mid+2;
            else right=mid;
        }
        return nums[left];
    }
};
```

##  第一个错误的版本（leetcode278)

```c++
你是产品经理，目前正在带领一个团队开发新的产品。不幸的是，你的产品的最新版本没有通过质量检测。由于每个版本都是基于之前的版本开发的，所以错误的版本之后的所有版本都是错的。
假设你有 n 个版本 [1, 2, ..., n]，你想找出导致之后所有版本出错的第一个错误的版本。
你可以通过调用 bool isBadVersion(version) 接口来判断版本号 version 是否在单元测试中出错。实现一个函数来查找第一个错误的版本。你应该尽量减少对调用 API 的次数。

示例:

给定 n = 5，并且 version = 4 是第一个错误的版本。
调用 isBadVersion(3) -> false
调用 isBadVersion(5) -> true
调用 isBadVersion(4) -> true
所以，4 是第一个错误的版本。
```

```c++
class Solution {
public:
    int firstBadVersion(int n) 
    {
        int left=1;
        int right=n;
        while(left<=right)
        {
            int mid=left+(right-left)/2;
            if(isBadVersion(mid)) right=mid-1;
            else left=mid+1;
        }   
        return left;
    }
};
```

## 寻找旋转排序数组中的最小值（leetcode153)

```c++
已知一个长度为 n 的数组，预先按照升序排列，经由 1 到 n 次 旋转 后，得到输入数组。例如，原数组 nums = [0,1,2,4,5,6,7] 在变化后可能得到：

    若旋转 4 次，则可以得到 [4,5,6,7,0,1,2]
    若旋转 7 次，则可以得到 [0,1,2,4,5,6,7]

注意，数组 [a[0], a[1], a[2], ..., a[n-1]] 旋转一次 的结果为数组 [a[n-1], a[0], a[1], a[2], ..., a[n-2]] 。

给你一个元素值 互不相同 的数组 nums ，它原来是一个升序排列的数组，并按上述情形进行了多次旋转。请你找出并返回数组中的 最小元素 。

示例 1：

输入：nums = [3,4,5,1,2]
输出：1
解释：原数组为 [1,2,3,4,5] ，旋转 3 次得到输入数组。
```

```c++
class Solution {
public:
    int findMin(vector<int>& nums) 
    {
        int left=0;
        int right=nums.size()-1;
        while(left<=right)
        {
            int mid=left+(right-left)/2;
            if(nums[mid]==nums[right]) return nums[mid];
            else if(nums[mid]<nums[right]) right=mid;
            else left=mid+1;
        }
        return nums[left];
    }
};
```

# 滑动窗口

```c++
/* 滑动窗口算法框架 */
void slidingWindow(string s, string t) {
    unordered_map<char, int> need, window;
    for (char c : t){
        need[c]++;
    }     
    int left = 0, right = 0;
    int valid = 0; 
    while (right < s.size()) {
        // c 是将移入窗口的字符
        char c = s[right];
        // 右移窗口
        right++;
        // 进行窗口内数据的一系列更新
        ...

        /*** debug 输出的位置 ***/
        printf("window: [%d, %d)\n", left, right);
        /********************/
        
        // 判断左侧窗口是否要收缩
        while (window needs shrink) {
            // d 是将移出窗口的字符
            char d = s[left];
            // 左移窗口
            left++;
            // 进行窗口内数据的一系列更新
            ...
        }
    }
}
```

## *最小覆盖子串（leetcode76)

```c++
给你一个字符串 s 、一个字符串 t 。返回 s 中涵盖 t 所有字符的最小子串。如果 s 中不存在涵盖 t 所有字符的子串，则返回空字符串 "" 。
注意：如果 s 中存在这样的子串，我们保证它是唯一的答案。 

示例 1：

输入：s = "ADOBECODEBANC", t = "ABC"
输出："BANC"
```

```c++
class Solution {
public:
    string minWindow(string s, string t) 
    {
        unordered_map<char,int> window,need;
        for(char c:t){
            ++need[c];
        } 
        int left=0;
        int right=0;
        int vaild=0;
        int minLength=INT_MAX;
        int start=0;
        while(right<s.size()){
            char c=s[right];
            ++right;
            if(need.count(c)){
                ++window[c];
                if(window[c]==need[c]) ++vaild;
            }
            while(vaild==need.size()){
                if(minLength>right-left){
                    minLength=right-left;
                    start=left;
                }
                char d=s[left];
                ++left;
                if(need.count(d)){
                    if(window[d]==need[d]) --vaild;
                    window[d]--;
                }
            }
        }
        return minLength==INT_MAX?"":s.substr(start,minLength);
    }
};
```

## 字符串的排列（leetcode567)

```c++
给定两个字符串 s1 和 s2，写一个函数来判断 s2 是否包含 s1 的排列。
换句话说，第一个字符串的排列之一是第二个字符串的 子串 。 

示例 1：
输入: s1 = "ab" s2 = "eidbaooo"
输出: True
解释: s2 包含 s1 的排列之一 ("ba").
```

```c++
class Solution {
public:
    bool checkInclusion(string s1, string s2) 
    {
        unordered_map<char,int> windows,need;
        for(char c: s1){
            ++need[c];
        }
        int left=0;
        int right=0;
        int vaild=0;
        while(right<s2.size()){
            char c=s2[right];
            ++right;
            if(need.count(c)){
                ++windows[c];
                if(windows[c]==need[c]){
                    ++vaild;
                }
            }
            while(vaild==need.size()){
                if(right-left==s1.size()) return true;
                char d=s2[left];
                ++left;
                if(need.count(d)){
                    if(windows[d]==need[d]){
                        --vaild;
                    }
                    --windows[d];
                }
            }
        }
        return false;
    }
};
```

## 找到字符串中所有字母异位词（leetcode438)

```c++
给定一个字符串 s 和一个非空字符串 p，找到 s 中所有是 p 的字母异位词的子串，返回这些子串的起始索引。
字符串只包含小写英文字母，并且字符串 s 和 p 的长度都不超过 20100。
说明：
    字母异位词指字母相同，但排列不同的字符串。
    不考虑答案输出的顺序。
示例 1:
输入:
s: "cbaebabacd" p: "abc"
输出:
[0, 6]
解释:
起始索引等于 0 的子串是 "cba", 它是 "abc" 的字母异位词。
起始索引等于 6 的子串是 "bac", 它是 "abc" 的字母异位词。
```

```c++
class Solution {
public:
    vector<int> findAnagrams(string s, string p) 
    {
        unordered_map<char,int> windows,need;
        for(char c: p){
            ++need[c];
        }
        int left=0;
        int right=0;
        int vaild=0;
        vector<int> res;
        while(right<s.size()){
            char c=s[right];
            ++right;
            if(need.count(c)){
                ++windows[c];
                if(windows[c]==need[c]){
                    ++vaild;
                }
            }
            while(vaild==need.size()){
                if(right-left==p.size()) res.push_back(left);
                char d=s[left];
                ++left;
                if(need.count(d)){
                    if(windows[d]==need[d]){
                        --vaild;
                    }
                    --windows[d];
                }
            }
        }
        return res;
    }
};
```

## 无重复字符的最长子串(leetcode438)

```c++
给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。
示例 1:

输入: s = "abcabcbb"
输出: 3 
解释: 因为无重复字符的最长子串是 "abc"，所以其长度为 3。
```

```c++
class Solution {
public:
    int lengthOfLongestSubstring(string s) 
    {
        unordered_map<char,int> windows;
        int left=0;
        int right=0;
        int length=0;
        while(right<s.size()){
            char c=s[right];
            ++right;
            ++windows[c];
            while(windows[c]>1){                
                char d=s[left];
                ++left; 
                --windows[d];
            }
            length=max(length,right-left);
        }
        return length;
    }
};
```

# 单调栈

## 下一个更大元素 I(leetcode496)

```c++
给你两个 没有重复元素 的数组 nums1 和 nums2 ，其中nums1 是 nums2 的子集。
请你找出 nums1 中每个元素在 nums2 中的下一个比其大的值。
nums1 中数字 x 的下一个更大元素是指 x 在 nums2 中对应位置的右边的第一个比 x 大的元素。如果不存在，对应位置输出 -1 。

示例 1:
输入: nums1 = [4,1,2], nums2 = [1,3,4,2].
输出: [-1,3,-1]
解释:
    对于 num1 中的数字 4 ，你无法在第二个数组中找到下一个更大的数字，因此输出 -1 。
    对于 num1 中的数字 1 ，第二个数组中数字1右边的下一个较大数字是 3 。
    对于 num1 中的数字 2 ，第二个数组中没有下一个更大的数字，因此输出 -1 。
```

```c++
class Solution {
public:
    vector<int> nextGreaterElement(vector<int>& nums1, vector<int>& nums2) 
    {
        unordered_map<int,int> m1;
        stack<int> sta;
        vector<int> res;
        int n=nums2.size();
        for(int i=n-1;i>=0;--i)                     //从后往前
        {
            while(!sta.empty()&&sta.top()<nums2[i]){//先扫除比自己小的
                sta.pop();
            }
            m1[nums2[i]]=sta.empty()?-1:sta.top();//再确认谁比我大
            sta.push(nums2[i]);
        }
        for(int num:nums1){                        //把自己填进stack
            res.push_back(m1[num]);
        }
        return res;
    }
};
```

## 下一个更大元素 II (leetcode496)

```C++
给定一个循环数组（最后一个元素的下一个元素是数组的第一个元素），输出每个元素的下一个更大元素。数字 x 的下一个更大的元素是按数组遍历顺序，这个数字之后的第一个比它更大的数，这意味着你应该循环地搜索它的下一个更大的数。如果不存在，则输出 -1。

示例 1:
输入: [1,2,1]
输出: [2,-1,2]
解释: 第一个 1 的下一个更大的数是 2；
数字 2 找不到下一个更大的数； 
第二个 1 的下一个最大的数需要循环搜索，结果也是 2。
```

```c++
class Solution {
public:
    vector<int> nextGreaterElements(vector<int>& nums) 
    {
        stack<int> sta;
        vector<int> res;
        int n=nums.size();
        for(int i=n-1;i>=0;--i){
            while(!sta.empty()&&nums[i]>=sta.top()){
                sta.pop();
            }
            sta.push(nums[i]);
        }
        for(int i=n-1;i>=0;--i){
            while(!sta.empty()&&nums[i]>=sta.top()){
                sta.pop();
            }
            int num=sta.empty()?-1:sta.top();
            res.push_back(num);
            sta.push(nums[i]);
        }
        return vector<int>(res.crbegin(),res.crend());//注意我们是从后遍历的
    }
};
```

## 每日温度 (leetcode739)

```c++
请根据每日气温列表，重新生成一个列表。对应位置的输出为：要想观测到更高的气温，至少需要等待的天数。如果气温在这之后都不会升高，请在该位置用 0 来代替。

例如，给定一个列表 temperatures = [73, 74, 75, 71, 69, 72, 76, 73]，你的输出应该是 [1, 1, 4, 2, 1, 1, 0, 0]。

提示：气温 列表长度的范围是 [1, 30000]。每个气温的值的均为华氏度，都是在 [30, 100] 范围内的整数。
```

```c++
class Solution {
public:
    vector<int> dailyTemperatures(vector<int>& temperatures) 
    {
        stack<int> sta;
        vector<int> res;
        int n=temperatures.size();
        for(int i=n-1;i>=0;--i){
            while(!sta.empty()&&temperatures[i]>=temperatures[sta.top()]){
                sta.pop();
            }
            int num=sta.empty()?0:sta.top()-i;
            res.push_back(num);
            sta.push(i);
        }
        return vector<int>(res.crbegin(),res.crend());
    }
};
```

# 动态规划

 **动态规划问题一定会具备「最优子结构」** 

 **明确「状态」 -> 定义 dp 数组/函数的含义 -> 明确「选择」-> 明确 base case**

## 基本题-凑零钱问题

```c++
int coinChange(vector<int>& coins, int amount) {
    // 数组大小为 amount + 1，初始值也为 amount + 1
    vector<int> dp(amount + 1, amount + 1);
    // base case
    dp[0] = 0;
    for (int i = 0; i < dp.size(); i++) {
        // 内层 for 在求所有子问题 + 1 的最小值
        for (int coin : coins) {
            // 子问题无解，跳过
            if (i - coin < 0) continue;
            dp[i] = min(dp[i], 1 + dp[i - coin]);
        }
    }
    return (dp[amount] == amount + 1) ? -1 : dp[amount];
}
```

## 背包问题

```c++
明确dp数组的定义:
`dp[i][j] = x`表示，对于前`i`个物品，当前背包的容量为`j`时，若`x`为`true`，则说明可以恰好将背包装满，若`x`为`false`，则说明不能恰好将背包装满。 
```

###  0-1背包

#### 分割等和子集(leetcode438)

```c++
给你一个 只包含正整数 的 非空 数组 nums 。请你判断是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。 

示例 1：
输入：nums = [1,5,11,5]
输出：true
解释：数组可以分割成 [1, 5, 5] 和 [11] 。
```

```c++
class Solution {
public:
    bool canPartition(vector<int>& nums) 
    {
        int size=nums.size();
        if(size==0) return false;
        int count=0;
        for(int num:nums){
            count+=num;
        }
        if(count%2==1) return false;
        count/=2;
        vector<vector<bool> > dp(size,vector<bool>(count+1,false));
        for(int i=0;i<size;++i){
            dp[i][0]=true;
        }
        for(int i=1;i<size;++i){
            for(int j=1;j<count+1;++j){
                if(j<nums[i-1]){
                    dp[i][j]=dp[i-1][j];//不拿
                }else{
                    dp[i][j]=dp[i-1][j]||dp[i-1][j-nums[i-1]];拿
                }
            }
        }
        return dp[size-1][count];
    }
};
```

#### 目标和(leetcode494)

```c++
输入：nums = [1,1,1,1,1], target = 3
输出：5
解释：一共有 5 种方法让最终目标和为 3 。
-1 + 1 + 1 + 1 + 1 = 3
+1 - 1 + 1 + 1 + 1 = 3
+1 + 1 - 1 + 1 + 1 = 3
+1 + 1 + 1 - 1 + 1 = 3
+1 + 1 + 1 + 1 - 1 = 3
```

```c++
思路：
sum(A) - sum(B) = target
sum(A) = target + sum(B)
sum(A) + sum(A) = target + sum(B) + sum(A)
2 * sum(A) = target + sum(nums)
sum(A) = (target + sum(nums)) / 2
```

```c++
class Solution {
public:
    int findTargetSumWays(vector<int>& nums, int target) 
    {
        if(nums.size()==0) return 0;
        for(int num:nums){
            target+=num;
        }
        if(target%2==1) return 0;
        target/=2;    //目标
        vector<vector<int>> dp(nums.size()+1,vector<int>(target+1,0));
        for(int i=0;i<nums.size();++i){
            dp[i][0]=1;
        }
        for(int i=1;i<=nums.size();++i){
            for(int j=0;j<=target;++j){
                if(j>=nums[i-1])
                    dp[i][j]=dp[i-1][j]+dp[i-1][j-nums[i-1]];  //拿
                else
                    dp[i][j]=dp[i-1][j];       //不拿
            }
        }
        return dp[nums.size()][target];
    }
};
```

### 完全背包问题

#### 零钱兑换II（leetcode518）

```c++
给定不同面额的硬币和一个总金额。写出函数来计算可以凑成总金额的硬币组合数。假设每一种面额的硬币有无限个。 
示例 1:
输入: amount = 5, coins = [1, 2, 5]
输出: 4
解释: 有四种方式可以凑成总金额:
5=5
5=2+2+1
5=2+1+1+1
5=1+1+1+1+1
```

```c++
class Solution {
public:
    int change(int amount, vector<int>& coins) 
    {
        int n=coins.size();
        vector<vector<int>> dp(n+1,vector<int>(amount+1,0));
        for(int i=0;i<n+1;++i){
            dp[i][0]=1;
        }
        for(int i=1;i<=n;++i){
            for(int j=0;j<=amount;++j){
                if(j-coins[i-1]>=0){
                    dp[i][j]=dp[i-1][j]+dp[i][j-coins[i-1]];
         //和0-1背包dp[i][j]=dp[i-1][j]+dp[i-1][j-coins[i-1]]
                }
                else dp[i][j]=dp[i-1][j];
            }
        }
        return dp[n][amount];
    }
};
```

#### 零钱兑换II（leetcode322）

```c++
给定不同面额的硬币 coins 和一个总金额 amount。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 -1。
你可以认为每种硬币的数量是无限的。
示例 1：

输入：coins = [1, 2, 5], amount = 11
输出：3 
解释：11 = 5 + 5 + 1
```

```c++
class Solution {
public:
    int coinChange(vector<int>& coins, int amount) 
    {
        int n=coins.size();
        vector<vector<int>> dp(n+1,vector<int>(amount+1,amount+1));
        for(int i=0;i<n+1;++i){
            dp[i][0]=0;
        }
        for(int i=1;i<=n;++i){
            for(int j=0;j<=amount;++j){
                if(j-coins[i-1]>=0){
                    dp[i][j]=min(dp[i-1][j],1 + dp[i][j-coins[i-1]]);
                }
                else dp[i][j]=dp[i-1][j];
            }
        }
        return dp[n][amount]==amount+1?-1:dp[n][amount];
    }
};
```

## 子序列类型问题

### 编辑距离（leetcode72）

```c++
给你两个单词 word1 和 word2，请你计算出将 word1 转换成 word2 所使用的最少操作数 。
你可以对一个单词进行如下三种操作：
    插入一个字符
    删除一个字符
    替换一个字符

示例 1：
输入：word1 = "horse", word2 = "ros"
输出：3
解释：
horse -> rorse (将 'h' 替换为 'r')
rorse -> rose (删除 'r')
rose -> ros (删除 'e')
```

```c++
class Solution {
public:
    int minDistance(string word1, string word2) 
    {
        int n1=word1.size();
        int n2=word2.size();
        vector<vector<int>> dp(n1+1,vector<int>(n2+1,0));
        for(int i=0;i<=n1;++i){
            dp[i][0]=i;
        }
        for(int j=0;j<=n2;++j){
            dp[0][j]=j;
        }
        for(int i=1;i<=n1;++i){
            for(int j=1;j<=n2;++j){
                if(word1[i-1]==word2[j-1]) dp[i][j]=dp[i-1][j-1];//相同不操作
                else{
                    dp[i][j]=min(dp[i-1][j-1]+1,min(dp[i-1][j]+1,dp[i][j-1]+1));
                    //不同，替换([i-1][j-1])，删除([i-1][j])，插入([i][j-1])，取最小
                }
            }
        }
        return dp[n1][n2];
    }
};
```

### *最长递增子序列（leetcode300）

```c++
给你一个整数数组 nums ，找到其中最长严格递增子序列的长度。
子序列是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，[3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。

示例 1：
输入：nums = [10,9,2,5,3,7,101,18]
输出：4
解释：最长递增子序列是 [2,3,7,101]，因此长度为 4 。
```

```c++
//既然是递增子序列，我们只要找到前面那些结尾比 3 小的子序列，然后把 3 接到最后，就可以形成一个新的递增子序列，而且这个新的子序列长度加一。
class Solution {
public:
    int lengthOfLIS(vector<int>& nums) 
    {
        int n=nums.size();
        vector<int> dp(n,1);//初始为1
        int res=1;
        for(int i=1;i<n;++i){
            for(int j=0;j<i;++j){
                if(nums[i]>nums[j]) dp[i]=max(dp[i],dp[j]+1);//比当前值小的，加上当前值进行比较
            }
            res=max(res,dp[i]);//记录最大值
        }
        return res;
    }
};
```

### 俄罗斯套娃信封问题（leetcode354）

```c++
给你一个二维整数数组 envelopes ，其中 envelopes[i] = [wi, hi] ，表示第 i 个信封的宽度和高度。
当另一个信封的宽度和高度都比这个信封大的时候，这个信封就可以放进另一个信封里，如同俄罗斯套娃一样。
请计算 最多能有多少个 信封能组成一组“俄罗斯套娃”信封（即可以把一个信封放到另一个信封里面）。
注意：不允许旋转信封。 

示例 1：
输入：envelopes = [[5,4],[6,4],[6,7],[2,3]]
输出：3
解释：最多信封的个数为 3, 组合为: [2,3] => [5,4] => [6,7]。
```

```c++
//思路：最长递增子序列（先排序第一个数升序排列，第一个数相同的降序排列）
class Solution {
public:
    static bool cmp(const vector<int>& c1,const vector<int>& c2)
    {
        if(c1[0]==c2[0]) return c1[1]>c2[1];
        return c1[0]<c2[0];
    }
    int maxEnvelopes(vector<vector<int>>& envelopes) 
    {
        sort(envelopes.begin(),envelopes.end(),cmp);
        int n=envelopes.size();
        vector<int> dp(n,1);
        int res=1;
        for(int i=1;i<n;++i){
            for(int j=0;j<i;++j){
                if(envelopes[i][1]>envelopes[j][1]) dp[i]=max(dp[i],dp[j]+1);
            }
            res=max(res,dp[i]);
        }
        return res;
    }
};
```

### 最大子序和(leetcode53)

```c++
给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。
示例 1：
输入：nums = [-2,1,-3,4,-1,2,1,-5,4]
输出：6
解释：连续子数组 [4,-1,2,1] 的和最大，为 6 。
```

```c++
class Solution {
public:
    int maxSubArray(vector<int>& nums) 
    {
        int n=nums.size();
        vector<int> dp(n,0);
        dp[0]=nums[0];
        int res=dp[0];
        for(int i=1;i<n;++i){
            if(dp[i-1]>0) dp[i]=dp[i-1]+nums[i];//大于0的加
            else dp[i]=nums[i];//小于0就等于本身
            res=max(res,dp[i]); 
        }
        return res;
    }
};
```

### *最长公共子序列（leetcode1143）

```c++
输入：text1 = "abcde", text2 = "ace" 
输出：3  
解释：最长公共子序列是 "ace" ，它的长度为 3 。
```

```c++
class Solution {
public:
    int longestCommonSubsequence(string text1, string text2) 
    {
        int n1=text1.size();
        int n2=text2.size();
        vector<vector<int>> dp(n1+1,vector<int>(n2+1,0));
        for(int i=1;i<=n1;++i){
            for(int j=1;j<=n2;++j){
                if(text1[i-1]==text2[j-1]) dp[i][j]=dp[i-1][j-1]+1;
                else dp[i][j]=max(dp[i][j-1],dp[i-1][j]);
            }
        }
        return dp[n1][n2];
    }
};
```

### 两个字符串的删除操作（leetcode583）

```c++
给定两个单词 word1 和 word2，找到使得 word1 和 word2 相同所需的最小步数，每步可以删除任意一个字符串中的一个字符。
示例：
输入: "sea", "eat"
输出: 2
解释: 第一步将"sea"变为"ea"，第二步将"eat"变为"ea"
```

```c++
//思路：最长公共子序列
class Solution {
public:
    int minDistance(string word1, string word2) 
    {
        int n1=word1.size();
        int n2=word2.size();
        vector<vector<int>> dp(n1+1,vector<int>(n2+1,0));
        for(int i=1;i<=n1;++i){
            for(int j=1;j<=n2;++j){
                if(word1[i-1]==word2[j-1]) dp[i][j]=dp[i-1][j-1]+1;
                else dp[i][j]=max(dp[i][j-1],dp[i-1][j]);
            }
        }
        return n1+n2-(2*dp[n1][n2]);
    }
};
```

### 两个字符串的最小ASCII删除和（leetcode712）

```c++
给定两个字符串s1, s2，找到使两个字符串相等所需删除字符的ASCII值的最小和。
示例 1:
输入: s1 = "sea", s2 = "eat"
输出: 231
解释: 在 "sea" 中删除 "s" 并将 "s" 的值(115)加入总和。
在 "eat" 中删除 "t" 并将 116 加入总和。
结束时，两个字符串相等，115 + 116 = 231 就是符合条件的最小和。
```

```c++
class Solution {
public:
    int minimumDeleteSum(string s1, string s2) 
    {
        int n1=s1.size();
        int n2=s2.size();
        vector<vector<int>> dp(n1+1,vector<int>(n2+1,0));
        for(int i=0;i<=n1;++i){
            if(i==0) dp[i][0]=0;
            else dp[i][0]=dp[i-1][0]+s1[i-1];
        }
        for(int j=0;j<=n2;++j){
            if(j==0) dp[0][j]=0;
            else dp[0][j]=dp[0][j-1]+s2[j-1];
        }
        for(int i=1;i<=n1;++i){
            for(int j=1;j<=n2;++j){
                if(s1[i-1]==s2[j-1]) dp[i][j]=dp[i-1][j-1];
                else dp[i][j]=min(dp[i-1][j]+s1[i-1] , dp[i][j-1]+s2[j-1]);
            }
        }
        return dp[n1][n2];
    }
};
```

### *最长回文子序列（leetcode516）

```c++
给定一个字符串 s ，找到其中最长的回文子序列，并返回该序列的长度。可以假设 s 的最大长度为 1000 。 

示例 1:
输入:
"bbbab"
输出:
4

一个可能的最长回文子序列为 "bbbb"。
```

```c++
class Solution {
public:
    int longestPalindromeSubseq(string s) 
    {
        int n=s.size();
        vector<vector<int>> dp(n,vector<int>(n,0));
        for(int i=n-1;i>=0;--i){
            for(int j=i;j<n;++j){
                if(j==i) dp[i][j]=1;
                else{
                    if(s[i]==s[j]) dp[i][j]=dp[i+1][j-1]+2;
                    else dp[i][j]=max(dp[i+1][j],dp[i][j-1]);
                }
            }
        }
        return dp[0][n-1];
    }
};
```

## 动态规划之股票

```c++
比如 dp[3][2][1] 的含义就是：今天是第三天，我现在手上持有着股票，至今最多进行 2 次交易。
比如 dp[2][3][0] 的含义：今天是第二天，我现在手上没有持有股票，至今最多进行 3 次交易。
我们想求的最终答案是 dp[n - 1][K][0]，即最后一天，最多允许 K 次交易，最多获得多少利润。
```

**状态转移方程：**

```c++
dp[i][k][0] = max(dp[i-1][k][0], dp[i-1][k][1] + prices[i])
              max(   选择 rest  ,             选择 sell      )

解释：今天我没有持有股票，有两种可能：
要么是我昨天就没有持有，然后今天选择 rest，所以我今天还是没有持有；
要么是我昨天持有股票，但是今天我 sell 了，所以我今天没有持有股票了。

dp[i][k][1] = max(dp[i-1][k][1], dp[i-1][k-1][0] - prices[i])
              max(   选择 rest  ,           选择 buy         )

解释：今天我持有着股票，有两种可能：
要么我昨天就持有着股票，然后今天选择 rest，所以我今天还持有着股票；
要么我昨天本没有持有，但今天我选择 buy，所以今天我就持有股票了。
```

**初始化dp：**

```c++
dp[-1][k][0] = 0
解释：因为 i 是从 0 开始的，所以 i = -1 意味着还没有开始，这时候的利润当然是 0 。
dp[-1][k][1] = -infinity
解释：还没开始的时候，是不可能持有股票的，用负无穷表示这种不可能。
dp[i][0][0] = 0
解释：因为 k 是从 1 开始的，所以 k = 0 意味着根本不允许交易，这时候利润当然是 0 。
dp[i][0][1] = -infinity
解释：不允许交易的情况下，是不可能持有股票的，用负无穷表示这种不可能。
```

**总结：**

```c++
base case：
dp[-1][k][0] = dp[i][0][0] = 0
dp[-1][k][1] = dp[i][0][1] = -infinity

状态转移方程：
dp[i][k][0] = max(dp[i-1][k][0], dp[i-1][k][1] + prices[i])
dp[i][k][1] = max(dp[i-1][k][1], dp[i-1][k-1][0] - prices[i])
```

###  买卖股票的最佳时机（leetcode121）

```c++
给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。
你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。
返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。
 
示例 1：
输入：[7,1,5,3,6,4]
输出：5
解释：在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 =5。
     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。
```

```c++
思路：k=1
```

```c++
class Solution {
public:
    int maxProfit(vector<int>& prices) 
    {
        int n=prices.size();
        int dp[n][2];
        dp[0][0]=0;
        dp[0][1]=-prices[0];
        for(int i=1;i<n;++i)
        {
            dp[i][0]=max(dp[i-1][0],dp[i-1][1]+prices[i]);
            dp[i][1]=max(dp[i-1][1],-prices[i]);        //不同点
        }
        return dp[n-1][0];
    }
};
```

### 买卖股票的最佳时机II（leetcode122）

```c++
给定一个数组 prices ，其中 prices[i] 是一支给定股票第 i 天的价格。
设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。
注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。

示例 1:

输入: prices = [7,1,5,3,6,4]
输出: 7
解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。
     随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 。
```

```c++
k = +infinity
如果 k 为正无穷，那么就可以认为 k 和 k - 1 是一样的
我们发现数组中的 k 已经不会改变了，也就是说不需要记录 k 这个状态了
```

```C++
class Solution {
public:
    int maxProfit(vector<int>& prices) 
    {
        int n=prices.size();
        int dp[n][2];
        dp[0][0]=0;
        dp[0][1]=-prices[0];
        for(int i=1;i<n;++i)
        {
            dp[i][0]=max(dp[i-1][0],dp[i-1][1]+prices[i]);
            dp[i][1]=max(dp[i-1][1],dp[i-1][0]-prices[i]);//不同点
        }
        return dp[n-1][0];
    }
};
```

### 最佳买卖股票时机含冷冻期（leetcode309）

```c++
给定一个整数数组，其中第 i 个元素代表了第 i 天的股票价格 。
设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）:
    你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。
    卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。

示例:
输入: [1,2,3,0,2]
输出: 3 
解释: 对应的交易状态为: [买入, 卖出, 冷冻期, 买入, 卖出]
```

```c++
k = +infinity with cooldown
```

```c++
class Solution {
public:
    int maxProfit(vector<int>& prices) 
    {
        int n=prices.size();
        int dp[n][2];
        dp[0][0]=0;
        dp[0][1]=-prices[0];
        for(int i=1;i<n;++i)
        {
            dp[i][0]=max(dp[i-1][0],dp[i-1][1]+prices[i]);
            if(i<2) dp[i][1]=max(dp[i-1][1],0-prices[i]);
            else dp[i][1]=max(dp[i-1][1],dp[i-2][0]-prices[i]);
        }
        return dp[n-1][0];
    }
};
```

### 买卖股票的最佳时机含手续费（leetcode714）

```c++
给定一个整数数组 prices，其中第 i 个元素代表了第 i 天的股票价格 ；非负整数 fee 代表了交易股票的手续费用。
你可以无限次地完成交易，但是你每笔交易都需要付手续费。如果你已经购买了一个股票，在卖出它之前你就不能再继续购买股票了。
返回获得利润的最大值。

注意：这里的一笔交易指买入持有并卖出股票的整个过程，每笔交易你只需要为支付一次手续费。
示例 1:
输入: prices = [1, 3, 2, 8, 4, 9], fee = 2
输出: 8
解释: 能够达到的最大利润:  
在此处买入 prices[0] = 1
在此处卖出 prices[3] = 8
在此处买入 prices[4] = 4
在此处卖出 prices[5] = 9
总利润: ((8 - 1) - 2) + ((9 - 4) - 2) = 8.
```

```c++
k = +infinity with fee
```

```c++
class Solution {
public:
    int maxProfit(vector<int>& prices, int fee) 
    {
        int n=prices.size();
        int dp[n][2];
        dp[0][0]=0;
        dp[0][1]=-prices[0];
        for(int i=1;i<n;++i)
        {
            dp[i][0]=max(dp[i-1][0],dp[i-1][1]+prices[i]-fee);
            dp[i][1]=max(dp[i-1][1],dp[i-1][0]-prices[i]);
        }
        return dp[n-1][0];
    }
};
```

### 买卖股票的最佳时机III（leetcode123）

```c++
给定一个数组，它的第 i 个元素是一支给定的股票在第 i 天的价格。
设计一个算法来计算你所能获取的最大利润。你最多可以完成 两笔 交易。
注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。

示例 1:

输入：prices = [3,3,5,0,0,3,1,4]
输出：6
解释：在第 4 天（股票价格 = 0）的时候买入，在第 6 天（股票价格 = 3）的时候卖出，这笔交易所能获得利润 = 3-0 = 3 。
     随后，在第 7 天（股票价格 = 1）的时候买入，在第 8 天 （股票价格 = 4）的时候卖出，这笔交易所能获得利润 = 4-1 = 3 。
```

```c++
class Solution {
public:
    int maxProfit(vector<int>& prices) 
    {
        int n=prices.size();
        int dp[n][3][2];
         dp[i][1][0]=0;
        dp[i][1][1]=-prices[0];
        dp[i][2][0]=0;
        dp[i][2][1]=-prices[0];
        for(int i=1;i<n;++i)
        {
            dp[i][2][0]=max(dp[i-1][2][0],dp[i-1][2][1]+prices[i]);
            dp[i][2][1]=max(dp[i-1][2][1],dp[i-1][1][0]-prices[i]);
            dp[i][1][0]=max(dp[i-1][1][0],dp[i-1][1][1]+prices[i]);
            dp[i][1][1]=max(dp[i-1][1][1],-prices[i]);
        }
        return dp[n-1][2][0];
    }
};
```

### 买卖股票的最佳时机 IV（leetcode188)

```c++
给定一个整数数组 prices ，它的第 i 个元素 prices[i] 是一支给定的股票在第 i 天的价格。
设计一个算法来计算你所能获取的最大利润。你最多可以完成 k 笔交易。
注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。

示例 1：
输入：k = 2, prices = [2,4,1]
输出：2
解释：在第 1 天 (股票价格 = 2) 的时候买入，在第 2 天 (股票价格 = 4) 的时候卖出，这笔交易所能获得利润 = 4-2 = 2 。
```

```c++
k = any integer
```

```c++
class Solution {
public:
    int maxProfit(int k_max, vector<int>& prices) 
    {
        int n=prices.size();
        if(n==0||k_max==0) return 0;
        int dp[n][k_max+1][2];
        for(int i=0;i<n;++i)
        {
            for(int k=0;k<=k_max;++k)
            {
                if(k==0){
                    dp[i][k][0]=0;
                    dp[i][k][1]=0;
                    continue;
                }else if(i==0)
                {
                    dp[i][k][0]=0;
                    dp[i][k][1]=-prices[i];
                    continue;
                } 
                dp[i][k][0]=max(dp[i-1][k][0],dp[i-1][k][1]+prices[i]);
                dp[i][k][1]=max(dp[i-1][k][1],dp[i-1][k-1][0]-prices[i]);
            }
        }
        return dp[n-1][k_max][0];
    }
};
```

# 贪心算法

什么是贪心算法呢？贪心算法可以认为是动态规划算法的一个特例，相比动态规划，使用贪心算法需要满足更多的条件（贪心选择性质），但是效率比动态规划要高。

比如说一个算法问题使用暴力解法需要指数级时间，如果能使用动态规划消除重叠子问题，就可以降到多项式级别的时间，如果满足贪心选择性质，那么可以进一步降低时间复杂度，达到线性级别的。

什么是贪心选择性质呢，简单说就是：每一步都做出一个局部最优的选择，最终的结果就是全局最优。注意哦，这是一种特殊性质，其实只有一部分问题拥有这个性质。

比如你面前放着 100 张人民币，你只能拿十张，怎么才能拿最多的面额？显然每次选择剩下钞票中面值最大的一张，最后你的选择一定是最优的。

## 无重叠区间（leetcode435）

```c++
给定一个区间的集合，找到需要移除区间的最小数量，使剩余区间互不重叠。

注意:
    可以认为区间的终点总是大于它的起点。
    区间 [1,2] 和 [2,3] 的边界相互“接触”，但没有相互重叠。

示例 1:
输入: [ [1,2], [2,3], [3,4], [1,3] ]
输出: 1

解释: 移除 [1,3] 后，剩下的区间没有重叠。
```

```c++
所有区间中结束最早的.
class Solution {
public:
    static bool cmp(const vector<int>& c1,const vector<int>& c2){
        return c1[1]<c2[1];
    }
    int eraseOverlapIntervals(vector<vector<int>>& intervals) 
    {
        int n=intervals.size();
        if(n<=1) return 0;
        sort(intervals.begin(),intervals.end(),cmp);
        int temp=intervals[0][1];
        int count=1;
        for(int i=1;i<n;++i){
            if(intervals[i][0]>=temp){
                ++count;
                temp=intervals[i][1];
            }
        }
        return n-count;
    }
};
```

## 跳跃游戏（leetcode55）

```c++
给定一个非负整数数组 nums ，你最初位于数组的 第一个下标。
数组中的每个元素代表你在该位置可以跳跃的最大长度。
判断你是否能够到达最后一个下标。

示例 1：

输入：nums = [2,3,1,1,4]
输出：true
解释：可以先跳 1 步，从下标 0 到达下标 1, 然后再从下标 1 跳 3 步到达最后一个下标。
```

```c++
class Solution {
public:
    bool canJump(vector<int>& nums) 
    {
        int n=nums.size();
        int farthest=0;
        for(int i=0;i<n;++i)
        {
            farthest=max(farthest,nums[i]+i);
            if(farthest<=i) return true;
        }
        return false;
    }
};
```

## 跳跃游戏II（leetcode45）

```C++
给定一个非负整数数组，你最初位于数组的第一个位置。
数组中的每个元素代表你在该位置可以跳跃的最大长度。
你的目标是使用最少的跳跃次数到达数组的最后一个位置。
假设你总是可以到达数组的最后一个位置。 

示例 1:

输入: [2,3,1,1,4]
输出: 2
解释: 跳到最后一个位置的最小跳跃数是 2。
     从下标为 0 跳到下标为 1 的位置，跳 1 步，然后跳 3 步到达数组的最后一个位置。
```

```c++
class Solution {
public:
    int jump(vector<int>& nums) 
    {
        int n=nums.size();
        int farthest=0;
        int end=0;
        int jumps=0;
        for(int i=0;i<n-1;++i){
            farthest=max(farthest,nums[i]+i);
            if(end==i){
                ++jumps;
                end=farthest;
            }
        }
        return jumps;
    }
};
```

# 二叉树

## 平衡二叉树（leetcode110）

本题中，一棵高度平衡二叉树定义为：一个二叉树*每个节点* 的左右两个子树的高度差的绝对值不超过 1 .

```c++
思路：
1.从底向顶
2.赋值剪枝，不符合条件，向上传-1；
3.返回值：孩子的高度 max(left,right)+1
4.处理：高度差绝对值小于2
```

```c++
class Solution {
public:
    bool isBalanced(TreeNode* root) 
    {
        if(root==nullptr) return true;
        return dfs(root)!=-1;
    }
    int dfs(TreeNode* root){
        if(root==nullptr) return 0;
        int left=dfs(root->left);
        if(left==-1) return -1;
        int right=dfs(root->right);
        if(right==-1) return -1;
        if(abs(left-right)>1) return -1;
        return max(left,right)+1;
    }
};
```

# 前缀和

  ![img](https://labuladong.gitee.io/algo/images/%E5%89%8D%E7%BC%80%E5%92%8C/1.jpg) 

## 和为K的子数组（leetcode560）

```c++
给定一个整数数组和一个整数 k，你需要找到该数组中和为 k 的连续的子数组的个数。

示例 1 :

输入:nums = [1,1,1], k = 2
输出: 2 , [1,1] 与 [1,1] 为两种不同的情况。
```

```c++
class Solution {
public:
    int subarraySum(vector<int>& nums, int k) 
    {
        unordered_map<int,int> m1;
        int pre=0;
        int res=0;
        m1[0]=1;
        for(int num:nums){
            pre+=num;
            if(m1.count(pre-k)){
                res+=m1[pre-k];
            }
            ++m1[pre];
        }
        return res;
    }
};
```

## 航班预订统计（leetcode1109）

```c++
输入：bookings = [[1,2,10],[2,3,20],[2,5,25]], n = 5
输出：[10,55,45,25,25]
解释：
航班编号        1   2   3   4   5
预订记录 1 ：   10  10
预订记录 2 ：       20  20
预订记录 3 ：       25  25  25  25
总座位数：      10  55  45  25  25
因此，answer = [10,55,45,25,25]
```

```c++
class Solution {
public:
    vector<int> corpFlightBookings(vector<vector<int>>& bookings, int n) 
    {
        int size=bookings.size();
        vector<int> vec(n,0);
        for(int i=0;i<size;++i){
            vec[bookings[i][0]-1]+=bookings[i][2];
            if(bookings[i][1]<n) vec[bookings[i][1]]-=bookings[i][2];
        }
        int pre=0;
        for(int i=0;i<n;++i){
            vec[i]+=pre;
            pre=vec[i];
        }
        return vec;
    }
};
```

# 其他相关的

## 动态规划相关的

### 乘积最大子数组（leetcode152）

```c++
输入: [2,3,-2,4]
输出: 6
解释: 子数组 [2,3] 有最大乘积 6。
```

和最大子序和（lc53） 类似，不过由于乘积，考虑记录一个正数最大值pre_max和一个负数最小值pre_min，根据数字正负，和自身比较（连续原因），维护这两个值.

```c++
class Solution {
public:
    int maxProduct(vector<int>& nums) 
    {
        int size=nums.size();
        if(size<=0) return 0;        
        int pre_max=nums[0];
        int pre_min=nums[0];
        int res=nums[0];
        for(int i=1;i<size;++i)
        {
            if(nums[i]<0) swap(pre_max,pre_min);
            pre_max=max(pre_max*nums[i],nums[i]);
            pre_min=min(pre_min*nums[i],nums[i]);
            res=max(res,pre_max);
        }
        return res;
    }
};
```

# 数学智力题

## 用 Rand7() 实现 Rand10() (leetcode470)

 已有方法 `rand7` 可生成 1 到 7 范围内的均匀随机整数，试写一个方法 `rand10` 生成 1 到 10 范围内的均匀随机整数。 

```c++
(rand7()-1)*7+rand7()；
将 rand7()扩展到 rand49(),原则每个数字生成为等概率.
再把49去掉尾数再压缩到 rand10()上.
```

```c++
class Solution {
public:
    int rand10() 
    {
        int num=41;
        while(num>40){
            num=(rand7()-1)*7+rand7();
        }
        return (num-1)%10+1;
    }
};
```

## 计数素数 (leetcode204)

```c++
思路：
1.从2开始，1不是素数
2.素数的2倍，3倍...n倍都不是素数
```

```c++
class Solution {
public:
    int countPrimes(int n) 
    {
        vector<bool> dp(n+1,true);
        for(int i=2;i*i<n;++i)  //因数对称只要遍历到 sqrt(n) 即可
        {
            if(dp[i]){
                for(int j=i*2;j<n;j+=i){
                    dp[j]=false;
                }
            }
        }
        int count=0;
        for(int i=2;i<n;++i){
            if(dp[i]) ++count;
        }
        return count;
    }
};
```

## 位1的个数(leetcode191)

n&=(n-1),消除一位1.

```c++
输入：00000000000000000000000000001011
输出：3
解释：输入的二进制串 00000000000000000000000000001011 中，共有三位为 '1'。
```

```c++
class Solution {
public:
    int hammingWeight(uint32_t n) 
    {
        int res=0;
        while(n>0){
            n&=(n-1);
            ++res;
        }
        return res;
    }
};
```

## 丢失的数字(leetcode268)

```c++
给定一个包含 [0, n] 中 n 个数的数组 nums ，找出 [0, n] 这个范围内没有出现在数组中的那个数。
```

```c++
class Solution {
public:
    int missingNumber(vector<int>& nums) 
    {
        int size=nums.size();
        int res=0;
        for(int i=0;i<=size;++i){
            res^=i;
        }
        for(int num:nums){
            res^=num;
        }
        return res;
    }
};
```

# 其他面试题

## 螺旋矩阵（leetcode54）

 给你一个 `m` 行 `n` 列的矩阵 `matrix` ，请按照 **顺时针螺旋顺序** ，返回矩阵中的所有元素。 

```c++
class Solution {
public:
    vector<int> spiralOrder(vector<vector<int>>& matrix) 
    {
        int top=0;
        int bottom=matrix.size()-1;
        int left=0;
        int right=matrix[0].size()-1;
        vector<int> res;
        while(left<=right&&top<=bottom)
        {
            for(int i=left;i<=right;++i) res.push_back(matrix[top][i]);
            ++top;
            if(top>bottom) break;   

            for(int i=top;i<=bottom;++i) res.push_back(matrix[i][right]);
            --right;
            if(right<left) break;

            for(int i=right;i>=left;--i) res.push_back(matrix[bottom][i]);
            --bottom;
            if(bottom<top) break;

            for(int i=bottom;i>=top;--i) res.push_back(matrix[i][left]);
            ++left;
            if(left>right) break;
        }
        return res;
    }
};
```

## 计算器（面试题 16.26）

```c++
给定一个包含正整数、加(+)、减(-)、乘(*)、除(/)的算数表达式(括号除外)，计算其结果。

表达式仅包含非负整数，+， - ，*，/ 四种运算符和空格  。 整数除法仅保留整数部分。
```

```c++
输入: "3+2*2"
输出: 7
```

```c++
思路：设定一个数字跟前面一个符号，初始符号为+；
     若是‘+’，stack.push(num);
	若是‘-’，stack.push(-num);
	若是‘*’，stack.push(num*stack.top());
	若是‘+’，stack.push(stack.top()/num);
	最后把stack全部push并加到一起。
易错点：数字可以大于一位。
```

```c++
class Solution {
public:
    int calculate(string s)
    {
        stack<int> s1;
        char pre = '+';
        int res = 0;
        for (int i = 0; i < s.size(); ++i) {
            char c = s[i];
            if (c == ' ') continue;
            else if (c >= '0' && c <= '9') {
                int num = 0;
                while (i < s.size() && c >= '0' && c <= '9')
                {
                    num = num * 10 + (c - '0');
                    ++i;
                    c = s[i];
                }
                if (pre == '+') {
                    s1.push(num);
                }
                else if (pre == '-') {
                    s1.push(-num);
                }
                else if (pre == '*') {
                    int a = s1.top() * num;
                    s1.pop();
                    s1.push(a); 
                }
                else if (pre == '/') {
                    int a = s1.top() / num;
                    s1.pop();
                    s1.push(a);             
                }
            }
            if (c == '+'||c == '-'||c == '*'||c == '/') {
                pre = c;
            }
        }
        while (!s1.empty())
        {
            res += s1.top();
            s1.pop();
        }
        return res;
    }
};
```

## 最长有效括号（leetcode32）

```c++
给你一个只包含 '(' 和 ')' 的字符串，找出最长有效（格式正确且连续）括号子串的长度。
示例 1：
输入：s = "(()"
输出：2
解释：最长有效括号子串是 "()"
```

```c++
class Solution {
public:
    int longestValidParentheses(string s) 
    {
        stack<int> s1;
        vector<bool> m1(s.size(),true);
        for(int i=0;i<s.size();++i){
            if(s[i]=='(') s1.push(i);//把i push进去
            else{
                if(s1.empty()) m1[i]=false;
                else s1.pop();
            }
        }
        while(!s1.empty()){
            m1[s1.top()] =false;
            s1.pop();
        }
        int maxValue=0;
        int n=0;
        for(bool b:m1){
            if(b) ++n;
            else {
                maxValue=max(maxValue,n);
                n=0;
            } 
        }
        maxValue=max(maxValue,n);
        return maxValue;
    }
};
```

# MYSQL

## 大的国家（leetcode595）

```sql
查找面积超过 3,000,000 或者人口数超过 25,000,000 的国家.
```

```html
+-----------------+------------+------------+--------------+---------------+
| name            | continent  | area       | population   | gdp           |
+-----------------+------------+------------+--------------+---------------+
| Afghanistan     | Asia       | 652230     | 25500100     | 20343000      |
| Albania         | Europe     | 28748      | 2831741      | 12960000      |
| Algeria         | Africa     | 2381741    | 37100000     | 188681000     |
| Andorra         | Europe     | 468        | 78115        | 3712000       |
| Angola          | Africa     | 1246700    | 20609294     | 100990000     |
+-----------------+------------+------------+--------------+---------------+
```

```html
+--------------+-------------+--------------+
| name         | population  | area         |
+--------------+-------------+--------------+
| Afghanistan  | 25500100    | 652230       |
| Algeria      | 37100000    | 2381741      |
+--------------+-------------+--------------+
```

```sql
SELECT
    name, population, area
FROM
    world
WHERE
    area > 3000000 OR population > 25000000
;
```

 使用 or 会使索引会失效，在数据量较大的时候查找效率较低，通常建议使用 union 代替 or。 

```sql
SELECT
    name, population, area
FROM
    world
WHERE
    area > 3000000

UNION

SELECT
    name, population, area
FROM
    world
WHERE
    population > 25000000
;
```

### SQL Schema

```sql
DROP TABLE
IF
    EXISTS World;
CREATE TABLE World ( NAME VARCHAR ( 255 ), continent VARCHAR ( 255 ), area INT, population INT, gdp INT );
INSERT INTO World ( NAME, continent, area, population, gdp )
VALUES
    ( 'Afghanistan', 'Asia', '652230', '25500100', '203430000' ),
    ( 'Albania', 'Europe', '28748', '2831741', '129600000' ),
    ( 'Algeria', 'Africa', '2381741', '37100000', '1886810000' ),
    ( 'Andorra', 'Europe', '468', '78115', '37120000' ),
    ( 'Angola', 'Africa', '1246700', '20609294', '1009900000' );
```

## 变更性别（leetcode627）

```sql
给定一个 salary 表，如下所示，有 m = 男性 和 f = 女性 的值。交换所有的 f 和 m 值（例如，将所有 f 值更改为 m，反之亦然）。要求只使用一个更新（Update）语句，并且没有中间的临时表。
```

```sql
| id | name | sex | salary |
|----|------|-----|--------|
| 1  | A    | m   | 2500   |
| 2  | B    | f   | 1500   |
| 3  | C    | m   | 5500   |
| 4  | D    | f   | 500    |
```

```sql
UPDATE
    salary 
SET 
    sex=char(ASCII(sex)^ASCII('f')^ASCII('m'))
;
```

```sql
update salary set sex=IF(sex='f','m','f')
```

## 有趣的电影（leetcode620）

```sql
 	某城市开了一家新的电影院，吸引了很多人过来看电影。该电影院特别注意用户体验，专门有个 LED显示板做电影推荐，上面公布着影评和相关电影描述。
	作为该电影院的信息部主管，您需要编写一个 SQL查询，找出所有影片描述为非 boring (不无聊) 的并且 id 为奇数 的影片，结果请按等级 rating 排列。
```

```sql
+---------+-----------+--------------+-----------+
|   id    | movie     |  description |  rating   |
+---------+-----------+--------------+-----------+
|   1     | War       |   great 3D   |   8.9     |
|   2     | Science   |   fiction    |   8.5     |
|   3     | irish     |   boring     |   6.2     |
|   4     | Ice song  |   Fantacy    |   8.6     |
|   5     | House card|   Interesting|   9.1     |
+---------+-----------+--------------+-----------+
```

```sql
+---------+-----------+--------------+-----------+
|   id    | movie     |  description |  rating   |
+---------+-----------+--------------+-----------+
|   5     | House card|   Interesting|   9.1     |
|   1     | War       |   great 3D   |   8.9     |
+---------+-----------+--------------+-----------+
```

```sql
SELECT 
    id,movie,description,rating
FROM
    cinema
WHERE
    id%2=1 AND description!= 'boring'
ORDER BY 
    rating  DESC
;
```

## 超过5名学生的课（leetcode596）

```sql
有一个courses 表 ，有: student (学生) 和 class (课程)。

请列出所有超过或等于5名学生的课。
```

```sql
+---------+------------+
| student | class      |
+---------+------------+
| A       | Math       |
| B       | English    |
| C       | Math       |
| D       | Biology    |
| E       | Math       |
| F       | Computer   |
| G       | Math       |
| H       | Math       |
| I       | Math       |
+---------+------------+
```

```sql
+---------+
| class   |
+---------+
| Math    |
+---------+
```

```SQL
# Write your MySQL query statement below
SELECT
    class
FROM
    courses 
GROUP BY
    class
HAVING
    COUNT(DISTINCT student)>=5;
```

## 查找重复的电子邮箱（leetcode182）

```sql
编写一个 SQL 查询，查找 Person 表中所有重复的电子邮箱。
```

```sql
+----+---------+
| Id | Email   |
+----+---------+
| 1  | a@b.com |
| 2  | c@d.com |
| 3  | a@b.com |
+----+---------+
```

```sql
+---------+
| Email   |
+---------+
| a@b.com |
+---------+
```

```sql
# Write your MySQL query statement below
SELECT
    Email   
FROM
    Person
GROUP BY
    Email   
HAVING
    COUNT(DISTINCT Id)>=2;
```

## 删除重复的电子邮箱（leetcode196）

```SQL
编写一个 SQL 查询，来删除 Person 表中所有重复的电子邮箱，重复的邮箱里只保留 Id 最小 的那个。
```

```SQL
+----+------------------+
| Id | Email            |
+----+------------------+
| 1  | john@example.com |
| 2  | bob@example.com  |
| 3  | john@example.com |
+----+------------------+
Id 是这个表的主键。
```

```SQL
+----+------------------+
| Id | Email            |
+----+------------------+
| 1  | john@example.com |
| 2  | bob@example.com  |
+----+------------------+
```

```SQL
DELETE 
    P1
FROM
    Person P1
JOIN
    Person P2
WHERE
    P1.Email=P2.Email
    AND P1.Id>P2.Id;
```

## 组合两个表（leetcode175）

```SQL
表1: Person

+-------------+---------+
| 列名         | 类型     |
+-------------+---------+
| PersonId    | int     |
| FirstName   | varchar |
| LastName    | varchar |
+-------------+---------+
PersonId 是上表主键

表2: Address

+-------------+---------+
| 列名         | 类型    |
+-------------+---------+
| AddressId   | int     |
| PersonId    | int     |
| City        | varchar |
| State       | varchar |
+-------------+---------+
AddressId 是上表主键

编写一个 SQL 查询，满足条件：无论 person 是否有地址信息，都需要基于上述两表提供 person 的以下信息：
FirstName, LastName, City, State
```

```SQL
SELECT
    FirstName, LastName, City, State
FROM
    Person P
LEFT JOIN
    Address A
ON
    P.PersonId=A.PersonId 
```

## 超过经理收入的员工（leetcode181）

```SQL
Employee 表包含所有员工，他们的经理也属于员工。每个员工都有一个 Id，此外还有一列对应员工的经理的 Id。

+----+-------+--------+-----------+
| Id | Name  | Salary | ManagerId |
+----+-------+--------+-----------+
| 1  | Joe   | 70000  | 3         |
| 2  | Henry | 80000  | 4         |
| 3  | Sam   | 60000  | NULL      |
| 4  | Max   | 90000  | NULL      |
+----+-------+--------+-----------+

给定 Employee 表，编写一个 SQL 查询，该查询可以获取收入超过他们经理的员工的姓名。在上面的表格中，Joe 是唯一一个收入超过他的经理的员工。

+----------+
| Employee |
+----------+
| Joe      |
+----------+
```

```SQL
SELECT
    E1.Name Employee 
FROM
    Employee E1
JOIN
    Employee E2
ON
    E1.ManagerId=E2.Id
WHERE
    E1.Salary>E2.Salary
```

## 从不订购的客户（leetcode183）

```SQL
某网站包含两个表，Customers 表和 Orders 表。编写一个 SQL 查询，找出所有从不订购任何东西的客户。

Customers 表：

+----+-------+
| Id | Name  |
+----+-------+
| 1  | Joe   |
| 2  | Henry |
| 3  | Sam   |
| 4  | Max   |
+----+-------+

Orders 表：

+----+------------+
| Id | CustomerId |
+----+------------+
| 1  | 3          |
| 2  | 1          |
+----+------------+

例如给定上述表格，你的查询应返回：

+-----------+
| Customers |
+-----------+
| Henry     |
| Max       |
+-----------+
```

```SQL
SELECT
    C.Name Customers 
FROM
    Customers C
LEFT JOIN
    Orders O
ON
    C.Id=O.CustomerId 
WHERE
    O.CustomerId IS NULL;
```

## 部门工资最高的员工（leetcode184）

```SQL
Employee 表包含所有员工信息，每个员工有其对应的 Id, salary 和 department Id。

+----+-------+--------+--------------+
| Id | Name  | Salary | DepartmentId |
+----+-------+--------+--------------+
| 1  | Joe   | 70000  | 1            |
| 2  | Jim   | 90000  | 1            |
| 3  | Henry | 80000  | 2            |
| 4  | Sam   | 60000  | 2            |
| 5  | Max   | 90000  | 1            |
+----+-------+--------+--------------+

Department 表包含公司所有部门的信息。

+----+----------+
| Id | Name     |
+----+----------+
| 1  | IT       |
| 2  | Sales    |
+----+----------+

编写一个 SQL 查询，找出每个部门工资最高的员工。对于上述表，您的 SQL 查询应返回以下行（行的顺序无关紧要）。

+------------+----------+--------+
| Department | Employee | Salary |
+------------+----------+--------+
| IT         | Max      | 90000  |
| IT         | Jim      | 90000  |
| Sales      | Henry    | 80000  |
+------------+----------+--------+

解释：

Max 和 Jim 在 IT 部门的工资都是最高的，Henry 在销售部的工资最高。
```

```SQL
SELECT
    D.Name Department,E.Name Employee,E.Salary Salary
FROM
    Employee E
JOIN
    Department D
ON
    E.DepartmentId=D.Id 
WHERE
    (E.DepartmentId,Salary)IN(
     SELECT 
        E.DepartmentId,MAX(Salary)
     FROM 
        Employee E
     GROUP BY
        DepartmentId
     )
```

## 第二高的薪水（leetcode176）

```SQL
编写一个 SQL 查询，获取 Employee 表中第二高的薪水（Salary） 。

+----+--------+
| Id | Salary |
+----+--------+
| 1  | 100    |
| 2  | 200    |
| 3  | 300    |
+----+--------+

例如上述 Employee 表，SQL查询应该返回 200 作为第二高的薪水。如果不存在第二高的薪水，那么查询应返回 null。

+---------------------+
| SecondHighestSalary |
+---------------------+
| 200                 |
+---------------------+
```

```SQL
SELECT 
IFNULL(
(SELECT
    distinct Salary 
FROM
    Employee 
ORDER BY
    Salary DESC
LIMIT 
    1,1
),NULL) SecondHighestSalary 
```

## 第N高的薪水（leetcode177）

```sql
编写一个 SQL 查询，获取 Employee 表中第 n 高的薪水（Salary）。

+----+--------+
| Id | Salary |
+----+--------+
| 1  | 100    |
| 2  | 200    |
| 3  | 300    |
+----+--------+

例如上述 Employee 表，n = 2 时，应返回第二高的薪水 200。如果不存在第 n 高的薪水，那么查询应返回 null。

+------------------------+
| getNthHighestSalary(2) |
+------------------------+
| 200                    |
+------------------------+
```

```SQL
CREATE FUNCTION getNthHighestSalary(N INT) RETURNS INT
BEGIN
  SET N = N - 1;
  RETURN (
      # Write your MySQL query statement below.
      SELECT 
      IFNULL((
        SELECT
            DISTINCT Salary 
        FROM
            Employee 
        ORDER BY
            Salary DESC
        LIMIT
            N,1
      ),NULL) getNthHighestSalary
  );
END
```

